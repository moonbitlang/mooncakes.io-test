{
  "kind": "package",
  "relative_path": "immut/sorted_map",
  "module_path": "moonbitlang/core",
  "readme_content": "# Immutable Map\n\nAn immutable tree map based on size balanced tree.\n\n# Usage\n\n## Create\n\nYou can create an empty map using `new()` or construct it with a single key-value pair using `singleton()`.\n\n```moonbit\nlet map1 : @immut/sorted_map.T[String, Int] = @immut/sorted_map.new()\nlet map2 = @immut/sorted_map.singleton(\"a\", 1)\n```\n\nAlso, you can construct it from an array using `of()` or `from_array()`.\n\n```moonbit\nlet map = @immut/sorted_map.of([(\"a\", 1), (\"b\", 2), (\"c\", 3)])\n```\n\n## Insert & Lookup\n\nYou can use `insert()` to add a key-value pair to the map and create a new map. Or use `lookup()` to get the value associated with a key.\n\n```moonbit\nlet map : @immut/sorted_map.T[String,Int] = @immut/sorted_map.new()\nlet map = map.insert(\"a\", 1)\nprintln(map.lookup(\"a\")) // Some(1)\n```\n\n## Remove\n\nYou can use `remove()` to remove a key-value pair from the map.\n\n```moonbit\nlet map = @immut/sorted_map.of([(\"a\", 1), (\"b\", 2), (\"c\", 3)])\nlet map = map.remove(\"a\")\n```\n\n## Contains\n\nYou can use `contains()` to check whether a key exists.\n\n```moonbit\nlet map = @immut/sorted_map.of([(\"a\", 1), (\"b\", 2), (\"c\", 3)])\nprintln(map.contains(\"a\")) // true\nprintln(map.contains(\"d\")) // false\n```\n\n## Size\n\nYou can use `size()` to get the number of key-value pairs in the map.\n\n```moonbit\nlet map = @immut/sorted_map.of([(\"a\", 1), (\"b\", 2), (\"c\", 3)])\nprintln(map.size()) // 3\n```\n\nSimilarly, you can use `is_empty()` to check whether the map is empty.\n\n```moonbit\nlet map : @immut/sorted_map.T[String, Int] = @immut/sorted_map.new()\nprintln(map.is_empty()) // true\n```\n\n## Traversal\n\nUse `each()` or `eachi()` to iterate through all key-value pairs.\n\n```moonbit\nlet map = @immut/sorted_map.of([(\"a\", 1), (\"b\", 2), (\"c\", 3)])\nmap.each(fn(k, v) { println(\"key:\\{k}, value:\\{v}\") })\nmap.eachi(fn(i, k, v) { println(\"index:\\{i}, key:\\{k}, value:\\{v}\") })\n```\n\nUse `map()` or `map_with_key()` to map a function over all values.\n\n```moonbit\nlet map = @immut/sorted_map.of([(\"a\", 1), (\"b\", 2), (\"c\", 3)])\nlet map = map.map(fn(v) { v + 1 })\nlet map = map.map_with_key(fn(_k, v) { v + 1 })\n```\n\nUse `fold()` or `foldl_with_key()` to fold the values in the map. The default order of fold is Pre-order.\nSimilarly, you can use `foldr_with_key()` to do a Post-order fold.\n\n```moonbit\nlet map = @immut/sorted_map.of([(\"a\", 1), (\"b\", 2), (\"c\", 3)])\nmap.fold(fn (acc, v) { acc + v }, ~init=0) // 6\nmap.foldl_with_key(fn (acc, k, v) { acc + k + v.to_string() }, ~init=\"\") // \"a1b2c3\"\nmap.foldr_with_key(fn (acc, k, v) { acc + k + v.to_string() }, ~init=\"\") // \"c3b2a1\"\n```\n\nUse `filter()` or `filter_with_key()` to filter all keys/values that satisfy the predicate.\n\n```moonbit\nlet map = @immut/sorted_map.of([(\"a\", 1), (\"b\", 2), (\"c\", 3)])\nlet map = map.filter(fn (v) { v > 1 })\nlet map = map.filter_with_key(fn (k, v) { k > \"a\" && v > 1 })\n```\n\n## Conversion\n\nUse `elems()` to get all values in ascending order of their keys.\n\n```moonbit\nlet map = @immut/sorted_map.of([(\"a\", 1), (\"b\", 2), (\"c\", 3)])\nlet elems = map.elems() // [1, 2, 3]\n```\n\nUse `keys()` to get all keys of the map in ascending order.\n\n```moonbit\nlet map = @immut/sorted_map.of([(\"a\", 1), (\"b\", 2), (\"c\", 3)])\nlet keys = map.keys() // [\"a\", \"b\", \"c\"]\n```\n\n",
  "package_data": "moonbitlang/core/immut/sorted_map/package_data.json",
  "source_files": [
    "deprecated.mbt", "inorder_iterator.mbt", "map.mbt", "traits_impl.mbt",
    "types.mbt", "utils.mbt"
  ]
}