{
  "kind": "package",
  "relative_path": "immut/list",
  "module_path": "moonbitlang/core",
  "readme_content": "# Immutable List\n\nList is implemented as a **linked list**, supporting O(1) head access.\n- Moonbit list is **homogeneous** list, which means all elements in the list must be of the same type.\n- Moonbit list does not support random access well, you can only access elements by iterating through the list. If you need randomly access the nth element, you should use `Array` instead.\n\n# Usage\n\n## Building lists \n\nYou can create a list manually via the `new()` or construct it using the `of()` method: \n```moonbit\nlet list0 : @immut/list.T[Int] = @immut/list.new()\nlet list1 = @immut/list.of([1, 2, 3, 4, 5])\n```\n\nOr use `Cons` constructor directly (Adds a single element to the beginning of a list):\n```moonbit\nlet list = @immut/list.Cons(1, Cons(2, Cons(3, Nil)))\n```\n\nBuild a repeated list by using the `repeat()` method:\n```moonbit\nprintln(@immut/list.repeat(3, 1)) // of([1, 1, 1])\n```\n\n## Pattern matching\nYou can use pattern matching to destructure a list:\n```moonbit\nlet list = @immut/list.of([1, 2, 3, 4, 5])\nmatch list {\n    Cons(head, tail) => println(head)\n    Nil => println(\"Empty list\")\n}\n```\n\n## Iterating over a list\nThe standard library provides a lot of tools for iterating over a list, such as `each()`, `eachi()`, etc. (For details check the API documentation)\n```moonbit\nlet list = @immut.list.of([1, 2, 3, 4, 5])\nlet list1 = list.each(fn (ele) { println(ele) }) \n```\n\n## Appending / Joining lists\nTo simply concatenate two lists, you can use the `concat()` method (or `+` operator):\n```moonbit\nlet list1 = @immut/list.of([1, 2, 3])\nlet list2 = @immut/list.of([4, 5, 6])\nlet list3 = list1.concat(list2) // of([1, 2, 3, 4, 5, 6])\nlet list4 = list1 + list2 // of([1, 2, 3, 4, 5, 6])\n```\n\nFor concatenating multiple lists (especially the length is unknown), you can use the `flatten()` method:\n```moonbit\nlet ls1 = @immut/list.of([1, 2, 3])\nlet ls2 = @immut/list.of([4, 5, 6])\nlet ls3 = @immut/list.of([7, 8, 9])\nlet ls4 = @immut/list.of([ls1, ls2, ls3])\nprintln(ls4.flatten()) // of([1, 2, 3, 4, 5, 6, 7, 8, 9])\n```\n\nTo insert separate elements into a list, you can use the `intersperse()` method:\n\n```moonbit\nlet list = @immut/list.of([1, 2, 3])\nprintln(list.intersperse(0)) // of([1, 0, 2, 0, 3])\n```\n\n## Filtering / Rejecting / Selecting elements\nThere are three ways to filter / reject / select multiple elements from a list:\n- Go through the entire list and decide whether the element should be present in the resultant list or not. Use `filter` for this.\n- To extract the first (or last) N elements of a list (and N is independent of the contents of the list). Use `take` or `drop` in this case.\n- To stop selecting elements (terminate the iteration) as soon as a condition is met, using `take_while` or `drop_while`\n\n```moonbit\nlet ls = @immut/list.of([1, 2, 3, 4, 5])\nls.filter(fn (ele) { ele % 2 == 0 }) // of([2, 4])\nls.take(2) // of([1, 2])\nls.drop(2) // of([3, 4, 5])\nls.take_while(fn (ele) { ele < 3 }) // of([1, 2])\nls.drop_while(fn (ele) { ele < 3 }) // of([3, 4, 5])\n```\n\n## Accessing elements / sub-lists\nYou can access the head of the list using the `head()` (O(1)) method. It returns `Some(head)` or `None` if the list is empty.\nAnd access the last element using the `last()` method (O(n)). \n\n```moonbit\nlet list = @immut/list.of([1, 2, 3, 4, 5])\nprintln(list.head()) // Some(1)\nprintln(list.last()) // 5\n```\n\nFor randomly accessing, you can use the `nth()` method, which returns the nth element in the list (O(n)). \nIf the index is out of bounds, it returns `None`.\n```moonbit\nlet list = @immut/list.of([1, 2, 3, 4, 5])\nlist.nth(2) // Some(3)\nlist.nth(8) // None\n```\n\nTo get a sub-list from the list, you can use the `init_()` method for getting all elements except the last one, and `tail()` for getting all elements except the first one.\n```moonbit\nlet list = @immut/list.of([1, 2, 3, 4, 5])\nlist.init_() // of([1, 2, 3, 4])\nlist.tail() // of([2, 3, 4, 5])\n```\n\n## Reducing Lists\nYou can reduce (fold) a list to a single value using the `fold()` method.\n```moonbit\nlet list = @immut/list.of([1, 2, 3, 4, 5])\nlist.fold(init=0, fn(acc, x) { acc + x }) // 15\n```\n\nThere are some special folds that you can use like `any`, `all`, `sum`, `maximum`, and `minimum`. Check the API documentation below for more details.\n\n## List transformations\nTo transform list elements, you can use the `map()` method.\n```moonbit\nlet list = @immut/list.of([1, 2, 3, 4, 5])\nlist.map(fn (ele) { ele * 2 }) // of([2, 4, 6, 8, 10])\n```\n\nThe `rev` method reverses the list.\n```moonbit\nlet list = @immut/list.of([1, 2, 3, 4, 5])\nlist.rev() // of([5, 4, 3, 2, 1])\n```",
  "package_data": "moonbitlang/core/immut/list/package_data.json",
  "source_files": [ "deprecated.mbt", "list.mbt", "types.mbt" ]
}