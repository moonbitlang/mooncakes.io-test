{
  "kind": "package",
  "relative_path": "deque",
  "module_path": "moonbitlang/core",
  "readme_content": "# Deque\n\nDeque is a double-ended queue implemented as a round-robin queue, supporting O(1) head or tail insertion and querying, just like double-ended queues in other languages(C++ std::deque / Rust VecDeque), here deque also supports random access.\n\n# Usage\n\n## Create\n\nYou can create a deque manually via the `new()` or construct it using the `of()`.\n\n```moonbit\nlet dv : @deque.T[Int] = @deque.new()\nlet dv = @deque.of([1, 2, 3, 4, 5])\n```\n\nIf you want to set the length at creation time to minimize expansion consumption, you can add parameter `capacity` to the `new()` function.\n\n```moonbit\nlet dv = @deque.new(capacity=10)\n```\n\n## Length & Capacity\n\nA deque is an indefinite-length, auto-expandable datatype. You can use `length()` to get the number of elements in the current queue, or `capacity()` to get the current capacity.\n\n```moonbit\nlet dv = @deque.of([1, 2, 3, 4, 5])\ndv.length() // 5\ndv.capacity() // 5\n```\n\nSimilarly, you can use the `is_empty` to determine whether the queue is empty.\n\n```moonbit\nlet dv : @deque[Int] = @deque.new()\ndv.is_empty() // true\n```\n\nYou can use `reserve_capacity` to reserve capacity, ensures that it can hold at least the number of elements\nspecified by the `capacity` argument.\n\n```moonbit\nlet dv = @deque.of([1])\ndv.reserve_capacity(10)\nprintln(dv.capacity()) // 10\n```\n\nAlso, you can use `shrink_to_fit` to shrink the capacity of the deque.\n\n```moonbit\nlet dv = @deque.new(capacity=10)\ndv.push_back(1)\ndv.push_back(2)\ndv.push_back(3)\nprintln(dv.capacity()) // 10\ndv.shrink_to_fit()\nprintln(dv.capacity()) // 3\n```\n\n## Front & Back & Get\n\nYou can use `front()` and `back()` to get the head and tail elements of the queue, respectively. Since the queue may be empty, their return values are both `Option`, or `None` if the queue is empty.\n\n```moonbit\nlet dv = @deque.of([1, 2, 3, 4, 5])\ndv.front() // Some(1)\ndv.back() // Some(5)\n```\n\nYou can also use `op_get` to access elements of the queue directly, but be careful not to cross the boundaries!\n\n```moonbit\nlet dv = @deque.of([1, 2, 3, 4, 5])\ndv[0] // 1\ndv[4] // 5\n```\n\n## Push & Set\n\nSince the queue is bi-directional, you can use `push_front()` and `push_back()` to add values to the head or tail of the queue, respectively.\n\n```moonbit\nlet dv = @deque.of([1, 2, 3, 4, 5])\ndv.push_front(6)\ndv.push_front(7)\ndv.push_back(8)\ndv.push_back(9)\n//now: 6 7 1 2 3 4 5 8 9\n```\n\nYou can also use `op_set` to set elements of the queue directly, but be careful not to cross the boundaries!\n\n```moonbit\nlet dv = @deque.of([1, 2, 3, 4, 5])\ndv[0] = 5\ndv[0] // 5\n```\n\n## Pop\n\nYou can use `pop_front()` and `pop_back()` to pop the element at the head or tail of the queue, respectively, and like [Front & Back](#Front & Back & Get), their return values are `Option`, loaded with the value of the element being popped.\n\n```moonbit\nlet dv = @deque.of([1, 2, 3, 4, 5])\nlet back = dv.pop_back() // Some(5)\ndv.back() // Some(4)\nlet front = dv.pop_front() //Some(1)\ndv.front() // Some(2)\ndv.length() // 3\n```\n\nIf you only want to pop an element without getting the return value, you can use `unsafe_pop_front()` with `unsafe_pop_back()`. These two functions will panic if the queue is empty.\n\n```moonbit\nlet dv = @deque.of([1, 2, 3, 4, 5])\ndv.unsafe_pop_front()\ndv.front() // Some(2)\ndv.unsafe_pop_back()\ndv.back() // Some(3)\n```\n\n## Clear\n\nYou can use `clear` to clear a deque. But note that the memory it already occupies does not change.\n\n```moonbit\nlet dv = @deque.of([1, 2, 3, 4, 5])\ndv.clear()\ndv.is_empty() // true\n```\n\n## Equal\n\ndeque supports comparing them directly using `op_equal`.\n\n```moonbit\nlet dqa = @deque.of([1, 2, 3, 4, 5])\nlet dqb = @deque.of([1, 2, 3, 4, 5])\ndqa == dqb // true\n```\n\n## Iter & Map\n\ndeque supports vector-like `iter/iteri/map/mapi` functions and their inverse forms.\n\n```moonbit\n let dv = @deque.of([1, 2, 3, 4, 5])\n dv.each(fn(elem) { print(elem) })\n dv.eachi(fn(i, _elem) { print(i) })\n dv.map(fn(elem) { elem + 1 })\n dv.mapi(fn(i, elem) { elem + i })\n```\n\n## Search & Contains\n\nYou can use `contains()` to find out if a value is in the deque, or `search()` to find its index in the deque.\n\n```moonbit\nlet dv = @deque.of([1, 2, 3, 4, 5])\ndv.contains(1) // true\ndv.contains(6) // false\ndv.search(1) // Some(0)\ndv.search(6) // None\n```\n",
  "package_data": "moonbitlang/core/deque/package_data.json",
  "source_files": [ "deprecated.mbt", "deque.mbt", "types.mbt" ]
}