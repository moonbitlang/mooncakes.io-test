{
  "kind": "package",
  "relative_path": "option",
  "module_path": "moonbitlang/core",
  "readme_content": "---\nmoonbit : true\n---\n\n# Option\n\nThe `Option` type is a built-in type in MoonBit that represents an optional value. The type annotation `Option[A]` can also be written as `A?`.\n\nIt is an enum with two variants: `Some(T)`, which represents a value of type `T`, and `None`, representing no value.\n\nNote that some methods of the Option are defined in the `core/builtin` package.\n\n# Usage\n\n## Create\nYou can create an `Option` value using the `Some` and `None` constructors, remember to give proper type annotations.\n\n```moonbit\nlet _some: Int? = Some(42)\nlet _none: String? = None\n```\n\nFor conditional expressions, you can use the `when` function, which returns `Some` if the condition is true, otherwise `None`. Note that the value is lazily evaluated.\n\n```moonbit\nlet some = @option.when(1 > 0, fn () { 42 })\nassert_eq!(some, Some(42))\nlet none = @option.when(1 < 0, fn () { 42 })\nassert_eq!(none, None)\n```\n\nThe dual version of `when` is the `unless` function, which returns `Some` if the condition is false, otherwise `None`.\n\n```moonbit\nlet some = @option.unless(1 < 0, fn () { 42 })\nassert_eq!(some, Some(42))\nlet none = @option.unless(1 > 0, fn () { 42 })\nassert_eq!(none, None)\n```\n\n## Extracting values\n\nYou can extract the value from an `Option` using the `match` expression (Pattern Matching).\n\n```moonbit\nlet i = Some(42)\nlet j = match i {\n    Some(value) => value\n    None => abort(\"unreachable\")\n}\nassert_eq!(j, 42)\n```\n\nOr using the `unwrap` method, which will panic if the result is `None` and return the value if it is `Some`.\n\n```moonbit\nlet some: Int? = Some(42)\nlet value = some.unwrap() // 42\nassert_eq!(value, 42)\n```\n\nA safer alternative to `unwrap` is the `or` method, which returns the value if it is `Some`, otherwise, it returns the default value.\n\n```moonbit\nlet none: Int? = None\nlet value = none.or(0) // 0\nassert_eq!(value, 0)\n```\n\nThere is also the `or_else` method, which returns the value if it is `Some`, otherwise, it returns the result of the provided function.\n\n```moonbit\nlet none: Int? = None\nlet value = none.or_else(fn() -> Int { 0 }) // 0\nassert_eq!(value, 0)\n```\n\n## Transforming values\n\nYou can transform the value of an `Option` using the `map` method. It applies the provided function to the value if it is `Some`, otherwise, it returns `None`.\n\n```moonbit\nlet some: Int? = Some(42)\nlet new_some = some.map(fn(value: Int) { value + 1 }) // Some(43)\nassert_eq!(new_some, Some(43))\n```\n\nThere is a `filter` method that applies a predicate to the value if it is `Some`, otherwise, it returns `None`.\n\n```moonbit\nlet some: Int? = Some(42)\nlet new_some = some.filter(fn(value: Int) { value > 40 }) // Some(42)\nlet none = some.filter(fn(value: Int) { value > 50 }) // None\nassert_eq!(new_some, Some(42))\nassert_eq!(none, None)\n```\n\n## Monadic operations\nYou can chain multiple operations that return `Option` using the `bind` method, which applies a function to the value if it is `Some`, otherwise, it returns `None`. Different from `map`, the function in argument returns an `Option`.\n\n```moonbit\nlet some: Int? = Some(42)\nlet new_some = some.bind(fn(value: Int) -> Int? { Some(value + 1) }) // Some(43)\nassert_eq!(new_some, Some(43))\n```\n\nSometimes we want to reduce the nested `Option` values into a single `Option`, you can use the `flatten` method to achieve this. It transforms `Some(Some(value))` into `Some(value)`, and `None` otherwise.\n\n```moonbit\nlet some: Option[Option[Int]] = Some(Some(42))\nlet new_some = some.flatten() // Some(42)\nassert_eq!(new_some, Some(42))\nlet none: Int?? = Some(None)\nlet new_none = none.flatten() // None\nassert_eq!(new_none, None)\n```\n",
  "package_data": "moonbitlang/core/option/package_data.json",
  "source_files": [ "option.mbt" ]
}