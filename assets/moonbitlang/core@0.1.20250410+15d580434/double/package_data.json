{
  "name": "moonbitlang/core/double",
  "traits": [],
  "types": [],
  "typealias": [],
  "values": [
    {
      "name": "abs",
      "docstring": "\n Returns the absolute value of a double-precision floating-point number.\n\n Parameters:\n\n * `value` : The double-precision floating-point number to compute the\n absolute value of.\n\n Returns the absolute value of the input number. For any input `x`, the result\n is equivalent to `if x < 0.0 { -x } else { x }`.\n\n Example:\n\n ```moonbit\n test \"abs\" {\n   inspect!((-2.5).abs(), content=\"2.5\")\n   inspect!(3.14.abs(), content=\"3.14\")\n   inspect!(0.0.abs(), content=\"0\")\n }\n ```",
      "signature": "fn abs(self : Double) -> Double",
      "loc": {
        "path": "moonbitlang/core/double",
        "file": "double.mbt",
        "line": 81,
        "column": 8
      }
    },
    {
      "name": "acos",
      "docstring": "\n Calculates the arccosine of a number.\n\n Parameters:\n\n * `x` : The number for which to calculate the arccosine.\n\n Returns the arccosine of the number `x`.\n\n * Returns NaN if the input is NaN.\n * Returns NaN if the input is less than -1 or greater than 1.\n\n Example:\n\n ```moonbit\n test \"acos\" {\n   inspect!(0.0.acos(), content=\"1.5707963267948966\")\n   inspect!(1.0.acos(), content=\"0\")\n   inspect!((-1.0).acos(), content=\"3.141592653589793\")\n   inspect!(@double.not_a_number.acos(), content=\"NaN\")\n   inspect!(@double.infinity.acos(), content=\"NaN\")\n   inspect!(@double.neg_infinity.acos(), content=\"NaN\")\n }\n ```",
      "signature": "fn acos(self : Double) -> Double",
      "loc": {
        "path": "moonbitlang/core/double",
        "file": "trig_nonjs.mbt",
        "line": 898,
        "column": 8
      }
    },
    {
      "name": "acosh",
      "docstring": "\n Calculates the inverse hyperbolic cosine of a number.\n\n Parameters:\n\n * `self` : The number for which to calculate the inverse hyperbolic cosine.\n\n Returns the inverse hyperbolic cosine of `self`.\n\n Special cases:\n\n * Returns `NaN` if `self` is less than `1`.\n * Returns `NaN` if `self` is `NaN`.\n * Returns `0` if `self` is `1`.\n * Returns `infinity` if `self` is `infinity` (Positive infinity).\n\n Example\n\n ```moonbit\n test \"acosh\" {\n   inspect!(1.0.acosh(), content=\"0\")\n   inspect!(2.0.acosh(), content=\"1.3169578969248166\")\n   inspect!(1000.0.acosh(), content=\"7.600902209541989\")\n   inspect!(@double.not_a_number.acosh(), content=\"NaN\")\n   inspect!(@double.infinity.acosh(), content=\"Infinity\")\n   inspect!((-1.0).acosh(), content=\"NaN\")\n   inspect!((-2.0).acosh(), content=\"NaN\")\n   inspect!(@double.neg_infinity.acosh(), content=\"NaN\")\n }\n ```",
      "signature": "fn acosh(self : Double) -> Double",
      "loc": {
        "path": "moonbitlang/core/double",
        "file": "hyperbolic_nonjs.mbt",
        "line": 304,
        "column": 8
      }
    },
    {
      "name": "asin",
      "docstring": "\n Calculates the arcsine of a number. Handles special cases and edge conditions\n according to IEEE 754 standards.\n\n Parameters:\n\n * `x` : The number for which to calculate the arcsine.\n\n Returns the arcsine of the number `x`.\n\n * Returns NaN if the input is NaN.\n * Returns NaN if the input is less than -1 or greater than 1.\n\n Example:\n\n ```moonbit\n test \"asin\" {\n   inspect!(0.0.asin(), content=\"0\")\n   inspect!(1.0.asin(), content=\"1.5707963267948966\")\n   inspect!((-1.0).asin(), content=\"-1.5707963267948966\")\n   inspect!(@double.not_a_number.asin(), content=\"NaN\")\n   inspect!(@double.infinity.asin(), content=\"NaN\")\n   inspect!(@double.neg_infinity.asin(), content=\"NaN\")\n }\n ```",
      "signature": "fn asin(self : Double) -> Double",
      "loc": {
        "path": "moonbitlang/core/double",
        "file": "trig_nonjs.mbt",
        "line": 816,
        "column": 8
      }
    },
    {
      "name": "asinh",
      "docstring": "\n Calculates the inverse hyperbolic sine of a number.\n\n Parameters:\n\n * `self` : The number for which to calculate the inverse hyperbolic sine.\n\n Returns the inverse hyperbolic sine of `self`.\n\n Special cases:\n\n * Returns `NaN` if `self` is `NaN`\n * Returns `infinity` if `self` is `infinity`\n\n Example\n\n ```moonbit\n test \"asinh\" {\n   inspect!(0.0.asinh(), content=\"0\")\n   inspect!((-0.0).asinh(), content=\"0\")\n   inspect!(1.0.asinh(), content=\"0.881373587019543\")\n   inspect!(2.0.asinh(), content=\"1.4436354751788103\")\n   inspect!(1000.0.asinh(), content=\"7.600902709541988\")\n   inspect!((-1000.0).asinh(), content=\"-7.600902709541988\")\n   inspect!(@double.not_a_number.asinh(), content=\"NaN\")\n   inspect!(@double.infinity.asinh(), content=\"Infinity\")\n   inspect!(@double.neg_infinity.asinh(), content=\"-Infinity\")\n }\n ```",
      "signature": "fn asinh(self : Double) -> Double",
      "loc": {
        "path": "moonbitlang/core/double",
        "file": "hyperbolic_nonjs.mbt",
        "line": 244,
        "column": 8
      }
    },
    {
      "name": "atan",
      "docstring": "\n Calculates the arctangent of a number.\n\n Parameters:\n\n * `x` : The number for which to calculate the arctangent.\n\n Returns the arctangent of the number `x`.\n\n Example:\n\n * Returns NaN if the input is NaN.\n\n ```moonbit\n test \"atan\" {\n   inspect!(0.0.atan(), content=\"0\")\n   inspect!(1.0.atan(), content=\"0.7853981633974483\")\n   inspect!((-1.0).atan(), content=\"-0.7853981633974483\")\n   inspect!(@double.not_a_number.atan(), content=\"NaN\")\n   inspect!(@double.infinity.atan(), content=\"1.5707963267948966\")\n   inspect!(@double.neg_infinity.atan(), content=\"-1.5707963267948966\")\n }\n ```",
      "signature": "fn atan(self : Double) -> Double",
      "loc": {
        "path": "moonbitlang/core/double",
        "file": "trig_nonjs.mbt",
        "line": 978,
        "column": 8
      }
    },
    {
      "name": "atan2",
      "docstring": "\n Calculates the arctangent of the quotient of two numbers.\n\n Parameters:\n\n * `self` : The numerator of the quotient.\n * `x` : The denominator of the quotient.\n\n Returns the arctangent of the quotient `self / x`.\n\n * Returns NaN if self or x is NaN.\n\n Example:\n\n ```moonbit\n test \"atan2\" {\n   inspect!(0.0.atan2(-1.0), content=\"3.141592653589793\")\n   inspect!(1.0.atan2(0.0), content=\"1.5707963267948966\")\n   inspect!(1.0.atan2(1.0), content=\"0.7853981633974483\")\n   inspect!(@double.not_a_number.atan2(1.0), content=\"NaN\")\n   inspect!(1.0.atan2(not_a_number), content=\"NaN\")\n   inspect!(@double.infinity.atan2(1.0), content=\"1.5707963267948966\")\n   inspect!(1.0.atan2(infinity), content=\"0\")\n   inspect!(@double.neg_infinity.atan2(1.0), content=\"-1.5707963267948966\")\n   inspect!(1.0.atan2(@double.neg_infinity), content=\"3.141592653589793\")\n   inspect!(@double.infinity.atan2(@double.infinity), content=\"0.7853981633974483\")\n   inspect!(@double.neg_infinity.atan2(@double.neg_infinity), content=\"-2.356194490192345\")\n   inspect!(@double.infinity.atan2(@double.neg_infinity), content=\"2.356194490192345\")\n   inspect!(@double.neg_infinity.atan2(@double.infinity), content=\"-0.7853981633974483\")\n }\n ```",
      "signature": "fn atan2(self : Double, x : Double) -> Double",
      "loc": {
        "path": "moonbitlang/core/double",
        "file": "trig_nonjs.mbt",
        "line": 1088,
        "column": 8
      }
    },
    {
      "name": "atanh",
      "docstring": "\n Calculates the inverse hyperbolic tangent of a number.\n\n Parameters:\n\n * `self` : The number for which to calculate the inverse hyperbolic tangent.\n\n Returns the inverse hyperbolic tangent of `self`.\n\n Special cases:\n\n * Returns `NaN` if `self` is less than `-1` or greater than `1`.\n * Returns `infinity` if `self` is `1`.\n * Returns `-infinity` if `self` is `-1`.\n\n Example\n\n ```moonbit\n test \"atanh\" {\n   inspect!(0.0.atanh(), content=\"0\")\n   inspect!((-0.0).atanh(), content=\"0\")\n   inspect!(0.5.atanh(), content=\"0.5493061443340548\")\n   inspect!((-0.5).atanh(), content=\"-0.5493061443340548\")\n   inspect!(1.0.atanh(), content=\"Infinity\")\n   inspect!((-1.0).atanh(), content=\"-Infinity\")\n   inspect!(1.5.atanh(), content=\"NaN\")\n   inspect!(@double.not_a_number.atanh(), content=\"NaN\")\n   inspect!(@double.infinity.atanh(), content=\"NaN\")\n   inspect!(@double.neg_infinity.atanh(), content=\"NaN\")\n }\n ```",
      "signature": "fn atanh(self : Double) -> Double",
      "loc": {
        "path": "moonbitlang/core/double",
        "file": "hyperbolic_nonjs.mbt",
        "line": 355,
        "column": 8
      }
    },
    {
      "name": "cbrt",
      "docstring": "\n Calculates the cube root of a number.\n\n Parameters:\n\n * `self` : The number for which to calculate the cube root.\n\n Returns the cube root of `self`.\n\n Special Cases:\n\n * Return `NaN` if `self` is `NaN`.\n * Return `±0` if `self` is `±0`.\n * Return `Infinity` if `self` is `Infinity`.\n * Return `-Infinity` if `self` is `-Infinity`.\n\n Example\n\n ```moonbit\n test \"cbrt\" {\n   inspect!(1.0.cbrt(), content=\"1\")\n   inspect!(3.0.cbrt(), content=\"1.4422495703074083\")\n   inspect!((-3.0).cbrt(), content=\"-1.4422495703074083\")\n   inspect!(10.0.cbrt(), content=\"2.154434690031884\")\n   inspect!(1000.0.cbrt(), content=\"10\")\n   inspect!(@double.not_a_number.cbrt(), content=\"NaN\")\n   inspect!(@double.infinity, content=\"Infinity\")\n   inspect!(@double.neg_infinity, content=\"-Infinity\")\n }\n ```",
      "signature": "fn cbrt(self : Double) -> Double",
      "loc": {
        "path": "moonbitlang/core/double",
        "file": "cbrt_nonjs.mbt",
        "line": 57,
        "column": 8
      }
    },
    {
      "name": "ceil",
      "docstring": "\n Returns the smallest integer greater than or equal to the given number.\n\n Parameters:\n\n * `self` : The floating point number to find the ceiling of.\n\n Returns the ceiling value of the input number.\n\n Example:\n\n ```moonbit\n test \"ceil\" {\n   inspect!(3.7.ceil(), content=\"4\")\n   inspect!((-3.7).ceil(), content=\"-3\")\n   inspect!(42.0.ceil(), content=\"42\")\n }\n ```",
      "signature": "fn ceil(self : Double) -> Double",
      "loc": {
        "path": "moonbitlang/core/double",
        "file": "round_wasm.mbt",
        "line": 54,
        "column": 8
      }
    },
    {
      "name": "cos",
      "docstring": "\n Calculates the cosine of a number in radians. Handles special cases and edge\n conditions according to IEEE 754 standards.\n\n Parameters:\n\n * `x` : The angle in radians for which to calculate the cosine.\n\n Returns the cosine of the angle `x`.\n\n Example:\n\n ```moonbit\n test \"cos\" {\n   inspect!(0.0.cos(), content=\"1\")\n   inspect!(2.5.cos(), content=\"-0.8011436155469337\")\n   inspect!((-3.141592653589793).cos(), content=\"-1\") // -pi\n   inspect!((-5.0).cos(), content=\"0.28366218546322625\")\n   inspect!(31415926535897.9323846.cos(), content=\"0.9999992690101899\")\n   inspect!(@double.not_a_number.cos(), content=\"NaN\")\n   inspect!(@double.infinity.cos(), content=\"NaN\")\n   inspect!(@double.neg_infinity.cos(), content=\"NaN\")\n }\n ```",
      "signature": "fn cos(self : Double) -> Double",
      "loc": {
        "path": "moonbitlang/core/double",
        "file": "trig_nonjs.mbt",
        "line": 734,
        "column": 8
      }
    },
    {
      "name": "cosh",
      "docstring": "\n Calculates the hyperbolic cosine of a number.\n\n Parameters:\n\n * `self` : The number for which to calculate the hyperbolic cosine.\n\n Returns the hyperbolic cosine of `self`.\n\n Special cases:\n\n * Returns `infinity` if `self` is `infinity`\n * Returns `NaN` if `self` is `NaN`\n\n Example\n\n ```moonbit\n test \"cosh\" {\n   inspect!(0.0.cosh(), content=\"1\")\n   inspect!((-0.0).cosh(), content=\"1\")\n   inspect!(1.0.cosh(), content=\"1.5430806348152437\")\n   inspect!(2.0.cosh(), content=\"3.7621956910836314\")\n   inspect!(1000.0.cosh(), content=\"Infinity\")\n   inspect!((-1000.0).cosh(), content=\"Infinity\")\n   inspect!(@double.not_a_number.cosh(), content=\"NaN\")\n   inspect!(@double.infinity.cosh(), content=\"Infinity\")\n   inspect!(@double.neg_infinity.cosh(), content=\"Infinity\")\n }\n ```",
      "signature": "fn cosh(self : Double) -> Double",
      "loc": {
        "path": "moonbitlang/core/double",
        "file": "hyperbolic_nonjs.mbt",
        "line": 121,
        "column": 8
      }
    },
    {
      "name": "exp",
      "docstring": "\n Computes `e` raised to the power of a given number.\n\n Parameters:\n\n * `self` : The exponent value to compute `e^x`.\n\n Returns the value of `e^x`, where `e` is Euler's number (approximately\n 2.71828).\n\n Special cases:\n\n * Returns `x` if `x` is `infinity` (positive infinity)\n * Returns `0` if `x` is negative infinity\n * Returns `NaN` if `x` is `NaN`\n * Returns `1` if `x` is `0`\n\n Example:\n\n ```moonbit\n test \"exp\" {\n   inspect!(0.0.exp(), content=\"1\")\n   inspect!(1.0.exp(), content=\"2.718281828459045\")\n   inspect!((-1.0).exp(), content=\"0.36787944117144233\")\n   inspect!(not_a_number.exp().is_nan(), content=\"true\")\n }\n ```",
      "signature": "fn exp(self : Double) -> Double",
      "loc": {
        "path": "moonbitlang/core/double",
        "file": "exp_nonjs.mbt",
        "line": 54,
        "column": 8
      }
    },
    {
      "name": "expm1",
      "docstring": "\n Calculates exp(x) - 1 accurately even when x is close to zero.\n\n Parameters:\n\n * `self` : The exponent.\n\n Returns e raised to the power of `self`, minus 1.\n\n Special Cases:\n\n * Returns NaN if `self` is NaN.\n * Returns -1 if `self` is negative infinity.\n * Returns `Infinity` if `self` is positive infinity.\n\n Example\n\n ```moonbit\n test \"expm1\" {\n   inspect!(0.0.expm1(), content=\"0\")\n   inspect!(1.0.expm1(), content=\"1.718281828459045\")\n   inspect!(2.0.expm1(), content=\"6.38905609893065\")\n   inspect!((-1.0).expm1(), content=\"-0.6321205588285577\")\n   inspect!((-2.0).expm1(), content=\"-0.8646647167633873\")\n   inspect!(@double.not_a_number.expm1(), content=\"NaN\")\n   inspect!(@double.infinity.expm1(), content=\"Infinity\")\n   inspect!(@double.neg_infinity.expm1(), content=\"-1\")\n }\n ```",
      "signature": "fn expm1(self : Double) -> Double",
      "loc": {
        "path": "moonbitlang/core/double",
        "file": "exp_nonjs.mbt",
        "line": 192,
        "column": 8
      }
    },
    {
      "name": "floor",
      "docstring": "\n Returns the largest integer less than or equal to the given number.\n\n Parameters:\n\n * `number` : A floating-point number to be rounded down.\n\n Returns a double-precision floating-point number representing the largest\n integer less than or equal to the input.\n\n Example:\n\n ```moonbit\n test \"floor\" {\n   inspect!(3.7.floor(), content=\"3\")\n   inspect!((-3.7).floor(), content=\"-4\")\n   inspect!(0.0.floor(), content=\"0\")\n }\n ```",
      "signature": "fn floor(self : Double) -> Double",
      "loc": {
        "path": "moonbitlang/core/double",
        "file": "round_wasm.mbt",
        "line": 75,
        "column": 8
      }
    },
    {
      "name": "from_int",
      "docstring": "\n same as Double::from_int`",
      "signature": "fn from_int(i : Int) -> Double",
      "loc": {
        "path": "moonbitlang/core/double",
        "file": "double.mbt",
        "line": 57,
        "column": 8
      }
    },
    {
      "name": "hypot",
      "docstring": "\n Calculates the the square root of the sum of the squares of its arguments.\n\n Parameters:\n\n * `self` : The number to be used as the first argument.\n * `y` : The number to be used as the second argument.\n\n Returns the hypotenuse of a right-angled triangle whose legs are `self` and `y`.\n\n Example:\n\n ```moonbit\n test \"hypot\" {\n   inspect!(3.0.hypot(4.0), content=\"5\")\n   inspect!(5.0.hypot(12.0), content=\"13\")\n   inspect!(8.0.hypot(15.0), content=\"17\")\n   inspect!(7.0.hypot(24.0), content=\"25\")\n   inspect!(@double.not_a_number.hypot(1.0), content=\"NaN\")\n   inspect!(1.0.hypot(@double.not_a_number), content=\"NaN\")\n   inspect!(@double.infinity.hypot(1.0), content=\"Infinity\")\n   inspect!(1.0.hypot(@double.infinity), content=\"Infinity\")\n   inspect!(@double.neg_infinity.hypot(1.0), content=\"Infinity\")\n   inspect!(1.0.hypot(@double.neg_infinity), content=\"Infinity\")\n }\n ```",
      "signature": "fn hypot(self : Double, y : Double) -> Double",
      "loc": {
        "path": "moonbitlang/core/double",
        "file": "hypot_nonjs.mbt",
        "line": 49,
        "column": 8
      }
    },
    {
      "name": "infinity",
      "docstring": "",
      "signature": "let infinity : Double",
      "loc": {
        "path": "moonbitlang/core/double",
        "file": "double.mbt",
        "line": 19,
        "column": 9
      }
    },
    {
      "name": "is_close",
      "docstring": "\n Determines whether two floating-point numbers are approximately equal within\n specified tolerances.\n The implementation follows the algorithm described in PEP 485 for Python's\n `math.isclose()`.\n\n Parameters:\n\n * `self` : The first floating-point number to compare.\n * `other` : The second floating-point number to compare.\n * `relative_tolerance` : The relative tolerance for the comparison. Must be\n non-negative. Defaults to 1e-9.\n * `absolute_tolerance` : The absolute tolerance for the comparison. Must be\n non-negative. Defaults to 0.0.\n\n Returns whether the two numbers are considered approximately equal. Returns\n `true` if the numbers are exactly equal or if they are within either the\n relative or absolute tolerance. Returns `false` if either number is infinite.\n\n Example:\n\n ```moonbit\n test \"is_close\" {\n   let x = 1.0\n   let y = 1.000000001\n   inspect!(x.is_close(y), content=\"false\")\n   inspect!(x.is_close(y, relative_tolerance=1.0e-10), content=\"false\")\n   inspect!(infinity.is_close(infinity), content=\"true\")\n }\n ```",
      "signature": "fn is_close(self : Double, other : Double, relative_tolerance~ : Double = .., absolute_tolerance~ : Double = ..) -> Bool",
      "loc": {
        "path": "moonbitlang/core/double",
        "file": "double.mbt",
        "line": 379,
        "column": 8
      }
    },
    {
      "name": "is_inf",
      "docstring": "\n Checks whether a double-precision floating-point number represents positive\n or negative infinity.\n\n Parameters:\n\n * `value` : The double-precision floating-point number to check.\n\n Returns `true` if the value is either positive or negative infinity, `false`\n otherwise.\n\n Example:\n\n ```moonbit\n test \"is_inf\" {\n   inspect!(infinity.is_inf(), content=\"true\")\n   inspect!(neg_infinity.is_inf(), content=\"true\")\n   inspect!(42.0.is_inf(), content=\"false\")\n }\n ```",
      "signature": "fn is_inf(self : Double) -> Bool",
      "loc": {
        "path": "moonbitlang/core/double",
        "file": "double.mbt",
        "line": 198,
        "column": 8
      }
    },
    {
      "name": "is_nan",
      "docstring": "\n Checks whether a double-precision floating-point number represents a \"Not a\n Number\" (NaN) value.\n\n Parameters:\n\n * `number` : A double-precision floating-point value to be checked.\n\n Returns `true` if the number is NaN, `false` otherwise.\n\n Example:\n\n ```moonbit\n test \"is_nan\" {\n   inspect!(not_a_number.is_nan(), content=\"true\")\n   inspect!(42.0.is_nan(), content=\"false\")\n   inspect!((0.0 / 0.0).is_nan(), content=\"true\")\n }\n ```",
      "signature": "fn is_nan(self : Double) -> Bool",
      "loc": {
        "path": "moonbitlang/core/double",
        "file": "double.mbt",
        "line": 173,
        "column": 8
      }
    },
    {
      "name": "is_neg_inf",
      "docstring": "\n Checks whether a double-precision floating-point number is negative infinity.\n\n Parameters:\n\n * `self` : The double-precision floating-point number to check.\n\n Returns a boolean value indicating whether the number is negative infinity.\n\n Example:\n\n ```moonbit\n test \"is_neg_inf\" {\n   inspect!((-1.0 / 0.0).is_neg_inf(), content=\"true\")\n   inspect!(42.0.is_neg_inf(), content=\"false\")\n   inspect!((1.0 / 0.0).is_neg_inf(), content=\"false\") // positive infinity\n }\n ```",
      "signature": "fn is_neg_inf(self : Double) -> Bool",
      "loc": {
        "path": "moonbitlang/core/double",
        "file": "double.mbt",
        "line": 242,
        "column": 8
      }
    },
    {
      "name": "is_pos_inf",
      "docstring": "\n Checks whether a double-precision floating-point number is positive infinity.\n\n Parameters:\n\n * `value` : The double-precision floating-point number to check.\n\n Returns `true` if the number is positive infinity, `false` otherwise.\n\n Example:\n\n ```moonbit\n test \"is_pos_inf\" {\n   inspect!(infinity.is_pos_inf(), content=\"true\")\n   inspect!(neg_infinity.is_pos_inf(), content=\"false\")\n   inspect!(42.0.is_pos_inf(), content=\"false\")\n }\n ```",
      "signature": "fn is_pos_inf(self : Double) -> Bool",
      "loc": {
        "path": "moonbitlang/core/double",
        "file": "double.mbt",
        "line": 220,
        "column": 8
      }
    },
    {
      "name": "ln",
      "docstring": "\n Calculates the natural logarithm of a double-precision floating-point number.\n\n Parameters:\n\n * `self`: The input number.\n\n Returns the natural logarithm of the input number, with the following special\n cases:\n\n * Returns NaN if the input is NaN or negative\n * Returns negative infinity if the input is zero\n * Returns the input if it is positive infinity\n\n Example:\n\n ```moonbit\n test \"ln\" {\n   inspect!(2.0.ln(), content=\"0.6931471805599453\")\n   inspect!(1.0.ln(), content=\"0\")\n   inspect!((-1.0).ln(), content=\"NaN\")\n   inspect!(0.0.ln(), content=\"-Infinity\")\n }\n ```",
      "signature": "fn ln(self : Double) -> Double",
      "loc": {
        "path": "moonbitlang/core/double",
        "file": "log_nonjs.mbt",
        "line": 106,
        "column": 8
      }
    },
    {
      "name": "ln_1p",
      "docstring": "\n Calculates ln(1 + x) accurately even when x is close to zero.\n\n Parameters:\n\n * `self` : The number to which 1 is added before calculating the logarithm.\n\n Returns the natural logarithm of 1 + `self`.\n\n Special Cases:\n\n * Returns `NaN` if `self` is `NaN` or less than -1.\n * Returns `-Infinity` if `self` is -1.\n * Returns `+Infinity` if `self` is `+Infinity`.\n\n Example:\n\n ```moonbit\n test \"ln_1p\" {\n   inspect!(0.0.ln_1p(), content=\"0\")\n   inspect!(1.0.ln_1p(), content=\"0.6931471805599453\")\n   inspect!(2.0.ln_1p(), content=\"1.0986122886681096\")\n   inspect!(@double.not_a_number.ln_1p(), content=\"NaN\")\n   inspect!((-1.0).ln_1p(), content=\"-Infinity\")\n   inspect!((-2.0).ln_1p(), content=\"NaN\")\n   inspect!(@double.infinity.ln_1p(), content=\"Infinity\")\n   inspect!(@double.neg_infinity.ln_1p(), content=\"NaN\")\n }\n ```",
      "signature": "fn ln_1p(self : Double) -> Double",
      "loc": {
        "path": "moonbitlang/core/double",
        "file": "log_nonjs.mbt",
        "line": 228,
        "column": 8
      }
    },
    {
      "name": "log10",
      "docstring": "\n Calculates the base-10 logarithm of a double-precision floating-point number.\n\n Parameters:\n\n * `self` : The double-precision floating-point number to calculate the\n logarithm of.\n\n Returns a double-precision floating-point number representing the base-10\n logarithm of the input.\n\n Example:\n\n ```moonbit\n test \"log10\" {\n   inspect!(0.1.log10(), content=\"-1\")\n   inspect!(1.0.log10(), content=\"0\")\n   inspect!(10.0.log10(), content=\"1\")\n   inspect!(100.0.log10(), content=\"2\")\n   inspect!(15.0.log10(), content=\"1.1760912590556813\")\n }\n ```",
      "signature": "fn log10(self : Double) -> Double",
      "loc": {
        "path": "moonbitlang/core/double",
        "file": "log_nonjs.mbt",
        "line": 178,
        "column": 8
      }
    },
    {
      "name": "log2",
      "docstring": "\n Calculates the base-2 logarithm of a double-precision floating-point number.\n\n Parameters:\n\n * `x` : A double-precision floating-point number.\n\n Returns the base-2 logarithm of the input number.\n\n Example:\n\n ```moonbit\n test \"log2\" {\n   inspect!(2.0.log2(), content=\"1\")\n   inspect!(0.5.log2(), content=\"-1\")\n   inspect!(3.0.log2(), content=\"1.584962500721156\")\n }\n ```",
      "signature": "fn log2(self : Double) -> Double",
      "loc": {
        "path": "moonbitlang/core/double",
        "file": "log_nonjs.mbt",
        "line": 148,
        "column": 8
      }
    },
    {
      "name": "max_value",
      "docstring": "",
      "signature": "let max_value : Double",
      "loc": {
        "path": "moonbitlang/core/double",
        "file": "double.mbt",
        "line": 25,
        "column": 9
      }
    },
    {
      "name": "min_positive",
      "docstring": "",
      "signature": "let min_positive : Double",
      "loc": {
        "path": "moonbitlang/core/double",
        "file": "double.mbt",
        "line": 31,
        "column": 9
      }
    },
    {
      "name": "min_value",
      "docstring": "",
      "signature": "let min_value : Double",
      "loc": {
        "path": "moonbitlang/core/double",
        "file": "double.mbt",
        "line": 28,
        "column": 9
      }
    },
    {
      "name": "neg_infinity",
      "docstring": "",
      "signature": "let neg_infinity : Double",
      "loc": {
        "path": "moonbitlang/core/double",
        "file": "double.mbt",
        "line": 22,
        "column": 9
      }
    },
    {
      "name": "not_a_number",
      "docstring": "",
      "signature": "let not_a_number : Double",
      "loc": {
        "path": "moonbitlang/core/double",
        "file": "double.mbt",
        "line": 16,
        "column": 9
      }
    },
    {
      "name": "pow",
      "docstring": "\n Calculates the power of a number by raising the base to the specified\n exponent. Handles special cases and edge conditions according to IEEE 754\n standards.\n\n Parameters:\n\n * `base` : The base number to be raised to a power.\n * `exponent` : The power to raise the base number to.\n\n Returns the result of raising `base` to the power of `exponent`.\n\n Example:\n\n ```moonbit\n test \"pow\" {\n   let x = 2.0\n   inspect!(x.pow(3.0), content=\"8\")\n   inspect!(x.pow(0.5), content=\"1.4142135623730951\")\n   inspect!(x.pow(0.0), content=\"1\")\n   inspect!((-1.0).pow(2.0), content=\"1\")\n   inspect!(0.0.pow(0.0), content=\"1\")\n   inspect!(infinity.pow(-1.0), content=\"0\")\n }\n ```",
      "signature": "fn pow(self : Double, other : Double) -> Double",
      "loc": {
        "path": "moonbitlang/core/double",
        "file": "pow_nonjs.mbt",
        "line": 135,
        "column": 8
      }
    },
    {
      "name": "round",
      "docstring": "\n Rounds a floating-point number to the nearest integer using \"round half up\"\n rule. In this rule, when a number is halfway between two integers (like 3.5),\n it is rounded up to the next integer.\n\n Parameters:\n\n * `value` : The floating-point number to be rounded.\n\n Returns the rounded value as a double-precision floating-point number.\n\n Example:\n\n ```moonbit\n test \"round\" {\n   inspect!(3.7.round(), content=\"4\")\n   inspect!(3.2.round(), content=\"3\")\n   inspect!(3.5.round(), content=\"4\")\n   inspect!((-3.5).round(), content=\"-3\")\n }\n ```",
      "signature": "fn round(self : Double) -> Double",
      "loc": {
        "path": "moonbitlang/core/double",
        "file": "round_wasm.mbt",
        "line": 98,
        "column": 8
      }
    },
    {
      "name": "signum",
      "docstring": "\n Returns the sign of the double.\n - If the double is positive, returns 1.0.\n - If the double is negative, returns -1.0.\n - Otherwise, returns the double itself (0.0, -0.0 and NaN).",
      "signature": "fn signum(self : Double) -> Double",
      "loc": {
        "path": "moonbitlang/core/double",
        "file": "double.mbt",
        "line": 88,
        "column": 8
      }
    },
    {
      "name": "sin",
      "docstring": "\n Calculates the sine of a number in radians. Handles special cases and edge\n conditions according to IEEE 754 standards.\n\n Parameters:\n\n * `x` : The angle in radians for which to calculate the sine.\n\n Returns the sine of the angle `x`.\n\n Example:\n\n ```moonbit\n test \"sin\" {\n   inspect!(0.0.sin(), content=\"0\")\n   inspect!(1.570796326794897.sin(), content=\"1\") // pi / 2\n   inspect!(2.0.sin(), content=\"0.9092974268256817\")\n   inspect!(-5.0.sin(), content=\"0.9589242746631385\")\n   inspect!(31415926535897.9323846.sin(), content=\"0.0012091232715481885\")\n   inspect!(@double.not_a_number.sin(), content=\"NaN\")\n   inspect!(@double.infinity.sin(), content=\"NaN\")\n   inspect!(@double.neg_infinity.sin(), content=\"NaN\")\n }\n ```",
      "signature": "fn sin(self : Double) -> Double",
      "loc": {
        "path": "moonbitlang/core/double",
        "file": "trig_nonjs.mbt",
        "line": 691,
        "column": 8
      }
    },
    {
      "name": "sinh",
      "docstring": "\n Calculates the hyperbolic sine of a number.\n\n Parameters:\n\n * `self` : The number for which to calculate the hyperbolic sine.\n\n Returns the hyperbolic sine of `self`.\n\n Special cases:\n\n * Returns `infinity` if `self` is `infinity`\n * Returns `NaN` if `self` is `NaN`\n\n Example:\n\n ```moonbit\n test \"sinh\" {\n   inspect!(0.0.sinh(), content=\"0\")\n   inspect!((-0.0).sinh(), content=\"0\")\n   inspect!(1.0.sinh(), content=\"1.1752011936438014\")\n   inspect!(2.0.sinh(), content=\"3.626860407847019\")\n   inspect!(1000.0.sinh(), content=\"Infinity\")\n   inspect!((-1000.0).sinh(), content=\"-Infinity\")\n   inspect!(@double.not_a_number.sinh(), content=\"NaN\")\n   inspect!(@double.infinity.sinh(), content=\"Infinity\")\n   inspect!(@double.neg_infinity.sinh(), content=\"-Infinity\")\n }\n ```",
      "signature": "fn sinh(self : Double) -> Double",
      "loc": {
        "path": "moonbitlang/core/double",
        "file": "hyperbolic_nonjs.mbt",
        "line": 61,
        "column": 8
      }
    },
    {
      "name": "tan",
      "docstring": "\n Calculates the tangent of a number in radians. Handles special cases and edge\n conditions according to IEEE 754 standards.\n\n Parameters:\n\n * `x` : The angle in radians for which to calculate the tangent.\n\n Returns the tangent of the angle `x`.\n\n Example:\n\n ```moonbit\n test \"tan\" {\n   inspect!(0.0.tan(), content=\"0\")\n   inspect!(0.7853981633974483.tan(), content=\"0.9999999999999999\")\n   inspect!(4.0.tan(), content=\"1.1578212823495777\")\n   inspect!(5.0.tan(), content=\"-3.380515006246586\")\n   inspect!(31415926535897.9323846.tan(), content=\"0.0012091241554056254\")\n   inspect!(@double.not_a_number.tan(), content=\"NaN\")\n   inspect!(@double.infinity.tan(), content=\"NaN\")\n   inspect!(@double.neg_infinity.tan(), content=\"NaN\")\n }\n ```",
      "signature": "fn tan(self : Double) -> Double",
      "loc": {
        "path": "moonbitlang/core/double",
        "file": "trig_nonjs.mbt",
        "line": 777,
        "column": 8
      }
    },
    {
      "name": "tanh",
      "docstring": "\n Calculates the hyperbolic tangent of a number.\n\n Parameters:\n\n * `self` : The number for which to calculate the hyperbolic tangent.\n\n Returns the hyperbolic tangent of `self`.\n\n Special cases:\n\n * Returns `NaN` if `self` is `NaN`\n * Returns `1` if `self` is `infinity`\n * Returns `-1` if `self` is `-infinity`\n\n Example\n\n ```moobit\n test \"tanh\" {\n   inspect!(0.0.tanh(), content=\"0\")\n   inspect!((-0.0).tanh(), content=\"0\")\n   inspect!(1.0.tanh(), content=\"0.7615941559557649\")\n   inspect!(2.0.tanh(), content=\"0.9640275800758169\")\n   inspect!(1000.0.tanh(), content=\"1\")\n   inspect!((-1000.0).tanh(), content=\"-1\")\n   inspect!(@double.not_a_number.tanh(), content=\"NaN\")\n   inspect!(@double.infinity.tanh(), content=\"1\")\n   inspect!(@double.neg_infinity.tanh(), content=\"-1\")\n }\n ```",
      "signature": "fn tanh(self : Double) -> Double",
      "loc": {
        "path": "moonbitlang/core/double",
        "file": "hyperbolic_nonjs.mbt",
        "line": 183,
        "column": 8
      }
    },
    {
      "name": "to_be_bytes",
      "docstring": "\n Converts a double-precision floating-point number to a sequence of bytes in\n big-endian byte order (most significant byte first).\n\n Parameters:\n\n * `self` : The double-precision floating-point number to be converted.\n\n Returns a sequence of 8 bytes representing the double-precision\n floating-point number in big-endian byte order.\n\n Example:\n\n ```moonbit\n test \"to_be_bytes\" {\n   let d = 1.0\n   inspect!(d.to_be_bytes(), content=\n   #|b\"\\x3f\\xf0\\x00\\x00\\x00\\x00\\x00\\x00\"\n )\n }\n ```",
      "signature": "fn to_be_bytes(self : Double) -> Bytes",
      "loc": {
        "path": "moonbitlang/core/double",
        "file": "double.mbt",
        "line": 423,
        "column": 8
      }
    },
    {
      "name": "to_le_bytes",
      "docstring": "\n Converts a double-precision floating-point number to a sequence of bytes in\n little-endian order (least significant byte first).\n\n Parameters:\n\n * `self` : A double-precision floating-point number to be converted.\n\n Returns a sequence of 8 bytes representing the double-precision\n floating-point number in little-endian order.\n\n Example:\n\n ```moonbit\n test \"to_le_bytes\" {\n   let d = 1.0\n   inspect!(d.to_le_bytes(), content=\n   #|b\"\\x00\\x00\\x00\\x00\\x00\\x00\\xf0\\x3f\"\n )\n }\n ```",
      "signature": "fn to_le_bytes(self : Double) -> Bytes",
      "loc": {
        "path": "moonbitlang/core/double",
        "file": "double.mbt",
        "line": 448,
        "column": 8
      }
    },
    {
      "name": "to_string",
      "docstring": "\n Converts a double-precision floating-point number to its string\n representation.\n\n Parameters:\n\n * `self`: The double-precision floating-point number to be converted.\n\n Returns a string representation of the double-precision floating-point\n number.\n\n Example:\n\n ```moonbit\n test \"Double::to_string\" {\n   inspect!(42.0.to_string(), content=\"42\")\n   inspect!(3.14159.to_string(), content=\"3.14159\")\n   inspect!((-0.0).to_string(), content=\"0\")\n   inspect!(not_a_number.to_string(), content=\"NaN\")\n }\n ```\n",
      "signature": "fn to_string(self : Double) -> String",
      "loc": {
        "path": "moonbitlang/core/double",
        "file": "double.mbt",
        "line": 340,
        "column": 8
      }
    },
    {
      "name": "to_uint",
      "docstring": "\n Converts a double-precision floating-point number to a 32-bit unsigned\n integer. Handles special cases including NaN and numbers outside the valid\n `UInt` range.\n\n Parameters:\n\n * `self` : The double-precision floating-point number to be converted.\n\n Returns an 32-bit unsigned integer value according to the following rules:\n\n * Returns 0 if the input is NaN\n * Returns `@uint.max_value` (4294967295U) if the input is greater than or\n   equal to `@uint.max_value`\n * Returns `@uint.min_value` (0U) if the input is less than or equal\n   to `@uint.min_value`\n * Otherwise returns the integer part of the input by truncating towards zero\n\n Example:\n\n ```moonbit\n test \"Double::to_uint/normal\" {\n   inspect!(42.0.to_uint(), content=\"42\")\n   inspect!((-42.5).to_uint(), content=\"0\")\n   inspect!((0.0 / 0.0).to_uint(), content=\"0\") // NaN\n   inspect!((1.0 / 0.0).to_uint(), content=\"4294967295\") // Infinity\n   inspect!((-1.0 / 0.0).to_uint(), content=\"0\") // -Infinity\n }\n ```",
      "signature": "fn to_uint(self : Double) -> UInt",
      "loc": {
        "path": "moonbitlang/core/double",
        "file": "to_uint_wasm.mbt",
        "line": 44,
        "column": 8
      }
    },
    {
      "name": "trunc",
      "docstring": "\n Returns an integer value by discarding the decimal part of the floating-point\n number (truncation toward zero).\n\n Parameters:\n\n * `self` : The floating-point number to be truncated.\n\n Returns a floating-point number representing the integer part of the input.\n\n Example:\n\n ```moonbit\n test \"trunc\" {\n   inspect!(3.7.trunc(), content=\"3\")\n   inspect!((-3.7).trunc(), content=\"-3\")\n   inspect!(0.0.trunc(), content=\"0\")\n }\n ```",
      "signature": "fn trunc(self : Double) -> Double",
      "loc": {
        "path": "moonbitlang/core/double",
        "file": "round_wasm.mbt",
        "line": 34,
        "column": 8
      }
    }
  ],
  "misc": [
    {
      "name": "Double",
      "impls": [
        {
          "self": { "name": "Double", "path": "moonbitlang/core/double" },
          "trait": { "name": "Hash", "path": "moonbitlang/core/builtin" },
          "methods": [
            {
              "name": "hash",
              "docstring": "",
              "signature": "fn hash(self : Double) -> Int",
              "loc": {
                "path": "moonbitlang/core/double",
                "file": "double.mbt",
                "line": 308,
                "column": 31
              }
            },
            {
              "name": "hash_combine",
              "docstring": "",
              "signature": "fn hash_combine(self : Double, hasher : <a href=\"moonbitlang/core/builtin#Hasher\">Hasher</a>) -> Unit",
              "loc": {
                "path": "moonbitlang/core/double",
                "file": "double.mbt",
                "line": 313,
                "column": 31
              }
            }
          ]
        },
        {
          "self": { "name": "Double", "path": "moonbitlang/core/double" },
          "trait": { "name": "Mod", "path": "moonbitlang/core/builtin" },
          "methods": [
            {
              "name": "op_mod",
              "docstring": "\n Calculates the floating-point remainder when `dividend` is divided by\n `divisor`. Returns NaN if either operand is NaN, or if `dividend` is\n infinity, or if `divisor` is zero.\n\n Parameters:\n\n * `dividend` : The floating-point number to be divided.\n * `divisor` : The floating-point number used to divide the `dividend`.\n\n Returns the remainder of the division. The result has the same sign as the\n `dividend` and has an absolute value less than the absolute value of\n `divisor`.\n\n Example:\n\n ```moonbit\n test \"op_mod\" {\n   inspect!(5.0.op_mod(3.0), content=\"2\")\n   inspect!((-5.0).op_mod(3.0), content=\"-2\")\n   inspect!(5.0.op_mod(not_a_number), content=\"NaN\")\n   inspect!(infinity.op_mod(3.0), content=\"NaN\")\n }\n ```",
              "signature": "fn op_mod(self : Double, other : Double) -> Double",
              "loc": {
                "path": "moonbitlang/core/double",
                "file": "mod_nonjs.mbt",
                "line": 39,
                "column": 30
              }
            }
          ]
        },
        {
          "self": { "name": "Double", "path": "moonbitlang/core/double" },
          "trait": { "name": "Show", "path": "moonbitlang/core/builtin" },
          "methods": [
            {
              "name": "output",
              "docstring": "",
              "signature": "fn output(self : Double, logger : <a href=\"moonbitlang/core/builtin#Logger\">Logger</a>) -> Unit",
              "loc": {
                "path": "moonbitlang/core/double",
                "file": "double.mbt",
                "line": 345,
                "column": 31
              }
            }
          ]
        }
      ],
      "methods": [
        {
          "name": "abs",
          "docstring": "\n Returns the absolute value of a double-precision floating-point number.\n\n Parameters:\n\n * `value` : The double-precision floating-point number to compute the\n absolute value of.\n\n Returns the absolute value of the input number. For any input `x`, the result\n is equivalent to `if x < 0.0 { -x } else { x }`.\n\n Example:\n\n ```moonbit\n test \"abs\" {\n   inspect!((-2.5).abs(), content=\"2.5\")\n   inspect!(3.14.abs(), content=\"3.14\")\n   inspect!(0.0.abs(), content=\"0\")\n }\n ```",
          "signature": "fn <a href=\"moonbitlang/core/double#Double\">Double</a>::abs(self : Double) -> Double",
          "loc": {
            "path": "moonbitlang/core/double",
            "file": "double.mbt",
            "line": 81,
            "column": 8
          }
        },
        {
          "name": "acos",
          "docstring": "\n Calculates the arccosine of a number.\n\n Parameters:\n\n * `x` : The number for which to calculate the arccosine.\n\n Returns the arccosine of the number `x`.\n\n * Returns NaN if the input is NaN.\n * Returns NaN if the input is less than -1 or greater than 1.\n\n Example:\n\n ```moonbit\n test \"acos\" {\n   inspect!(0.0.acos(), content=\"1.5707963267948966\")\n   inspect!(1.0.acos(), content=\"0\")\n   inspect!((-1.0).acos(), content=\"3.141592653589793\")\n   inspect!(@double.not_a_number.acos(), content=\"NaN\")\n   inspect!(@double.infinity.acos(), content=\"NaN\")\n   inspect!(@double.neg_infinity.acos(), content=\"NaN\")\n }\n ```",
          "signature": "fn <a href=\"moonbitlang/core/double#Double\">Double</a>::acos(self : Double) -> Double",
          "loc": {
            "path": "moonbitlang/core/double",
            "file": "trig_nonjs.mbt",
            "line": 898,
            "column": 8
          }
        },
        {
          "name": "acosh",
          "docstring": "\n Calculates the inverse hyperbolic cosine of a number.\n\n Parameters:\n\n * `self` : The number for which to calculate the inverse hyperbolic cosine.\n\n Returns the inverse hyperbolic cosine of `self`.\n\n Special cases:\n\n * Returns `NaN` if `self` is less than `1`.\n * Returns `NaN` if `self` is `NaN`.\n * Returns `0` if `self` is `1`.\n * Returns `infinity` if `self` is `infinity` (Positive infinity).\n\n Example\n\n ```moonbit\n test \"acosh\" {\n   inspect!(1.0.acosh(), content=\"0\")\n   inspect!(2.0.acosh(), content=\"1.3169578969248166\")\n   inspect!(1000.0.acosh(), content=\"7.600902209541989\")\n   inspect!(@double.not_a_number.acosh(), content=\"NaN\")\n   inspect!(@double.infinity.acosh(), content=\"Infinity\")\n   inspect!((-1.0).acosh(), content=\"NaN\")\n   inspect!((-2.0).acosh(), content=\"NaN\")\n   inspect!(@double.neg_infinity.acosh(), content=\"NaN\")\n }\n ```",
          "signature": "fn <a href=\"moonbitlang/core/double#Double\">Double</a>::acosh(self : Double) -> Double",
          "loc": {
            "path": "moonbitlang/core/double",
            "file": "hyperbolic_nonjs.mbt",
            "line": 304,
            "column": 8
          }
        },
        {
          "name": "asin",
          "docstring": "\n Calculates the arcsine of a number. Handles special cases and edge conditions\n according to IEEE 754 standards.\n\n Parameters:\n\n * `x` : The number for which to calculate the arcsine.\n\n Returns the arcsine of the number `x`.\n\n * Returns NaN if the input is NaN.\n * Returns NaN if the input is less than -1 or greater than 1.\n\n Example:\n\n ```moonbit\n test \"asin\" {\n   inspect!(0.0.asin(), content=\"0\")\n   inspect!(1.0.asin(), content=\"1.5707963267948966\")\n   inspect!((-1.0).asin(), content=\"-1.5707963267948966\")\n   inspect!(@double.not_a_number.asin(), content=\"NaN\")\n   inspect!(@double.infinity.asin(), content=\"NaN\")\n   inspect!(@double.neg_infinity.asin(), content=\"NaN\")\n }\n ```",
          "signature": "fn <a href=\"moonbitlang/core/double#Double\">Double</a>::asin(self : Double) -> Double",
          "loc": {
            "path": "moonbitlang/core/double",
            "file": "trig_nonjs.mbt",
            "line": 816,
            "column": 8
          }
        },
        {
          "name": "asinh",
          "docstring": "\n Calculates the inverse hyperbolic sine of a number.\n\n Parameters:\n\n * `self` : The number for which to calculate the inverse hyperbolic sine.\n\n Returns the inverse hyperbolic sine of `self`.\n\n Special cases:\n\n * Returns `NaN` if `self` is `NaN`\n * Returns `infinity` if `self` is `infinity`\n\n Example\n\n ```moonbit\n test \"asinh\" {\n   inspect!(0.0.asinh(), content=\"0\")\n   inspect!((-0.0).asinh(), content=\"0\")\n   inspect!(1.0.asinh(), content=\"0.881373587019543\")\n   inspect!(2.0.asinh(), content=\"1.4436354751788103\")\n   inspect!(1000.0.asinh(), content=\"7.600902709541988\")\n   inspect!((-1000.0).asinh(), content=\"-7.600902709541988\")\n   inspect!(@double.not_a_number.asinh(), content=\"NaN\")\n   inspect!(@double.infinity.asinh(), content=\"Infinity\")\n   inspect!(@double.neg_infinity.asinh(), content=\"-Infinity\")\n }\n ```",
          "signature": "fn <a href=\"moonbitlang/core/double#Double\">Double</a>::asinh(self : Double) -> Double",
          "loc": {
            "path": "moonbitlang/core/double",
            "file": "hyperbolic_nonjs.mbt",
            "line": 244,
            "column": 8
          }
        },
        {
          "name": "atan",
          "docstring": "\n Calculates the arctangent of a number.\n\n Parameters:\n\n * `x` : The number for which to calculate the arctangent.\n\n Returns the arctangent of the number `x`.\n\n Example:\n\n * Returns NaN if the input is NaN.\n\n ```moonbit\n test \"atan\" {\n   inspect!(0.0.atan(), content=\"0\")\n   inspect!(1.0.atan(), content=\"0.7853981633974483\")\n   inspect!((-1.0).atan(), content=\"-0.7853981633974483\")\n   inspect!(@double.not_a_number.atan(), content=\"NaN\")\n   inspect!(@double.infinity.atan(), content=\"1.5707963267948966\")\n   inspect!(@double.neg_infinity.atan(), content=\"-1.5707963267948966\")\n }\n ```",
          "signature": "fn <a href=\"moonbitlang/core/double#Double\">Double</a>::atan(self : Double) -> Double",
          "loc": {
            "path": "moonbitlang/core/double",
            "file": "trig_nonjs.mbt",
            "line": 978,
            "column": 8
          }
        },
        {
          "name": "atan2",
          "docstring": "\n Calculates the arctangent of the quotient of two numbers.\n\n Parameters:\n\n * `self` : The numerator of the quotient.\n * `x` : The denominator of the quotient.\n\n Returns the arctangent of the quotient `self / x`.\n\n * Returns NaN if self or x is NaN.\n\n Example:\n\n ```moonbit\n test \"atan2\" {\n   inspect!(0.0.atan2(-1.0), content=\"3.141592653589793\")\n   inspect!(1.0.atan2(0.0), content=\"1.5707963267948966\")\n   inspect!(1.0.atan2(1.0), content=\"0.7853981633974483\")\n   inspect!(@double.not_a_number.atan2(1.0), content=\"NaN\")\n   inspect!(1.0.atan2(not_a_number), content=\"NaN\")\n   inspect!(@double.infinity.atan2(1.0), content=\"1.5707963267948966\")\n   inspect!(1.0.atan2(infinity), content=\"0\")\n   inspect!(@double.neg_infinity.atan2(1.0), content=\"-1.5707963267948966\")\n   inspect!(1.0.atan2(@double.neg_infinity), content=\"3.141592653589793\")\n   inspect!(@double.infinity.atan2(@double.infinity), content=\"0.7853981633974483\")\n   inspect!(@double.neg_infinity.atan2(@double.neg_infinity), content=\"-2.356194490192345\")\n   inspect!(@double.infinity.atan2(@double.neg_infinity), content=\"2.356194490192345\")\n   inspect!(@double.neg_infinity.atan2(@double.infinity), content=\"-0.7853981633974483\")\n }\n ```",
          "signature": "fn <a href=\"moonbitlang/core/double#Double\">Double</a>::atan2(self : Double, x : Double) -> Double",
          "loc": {
            "path": "moonbitlang/core/double",
            "file": "trig_nonjs.mbt",
            "line": 1088,
            "column": 8
          }
        },
        {
          "name": "atanh",
          "docstring": "\n Calculates the inverse hyperbolic tangent of a number.\n\n Parameters:\n\n * `self` : The number for which to calculate the inverse hyperbolic tangent.\n\n Returns the inverse hyperbolic tangent of `self`.\n\n Special cases:\n\n * Returns `NaN` if `self` is less than `-1` or greater than `1`.\n * Returns `infinity` if `self` is `1`.\n * Returns `-infinity` if `self` is `-1`.\n\n Example\n\n ```moonbit\n test \"atanh\" {\n   inspect!(0.0.atanh(), content=\"0\")\n   inspect!((-0.0).atanh(), content=\"0\")\n   inspect!(0.5.atanh(), content=\"0.5493061443340548\")\n   inspect!((-0.5).atanh(), content=\"-0.5493061443340548\")\n   inspect!(1.0.atanh(), content=\"Infinity\")\n   inspect!((-1.0).atanh(), content=\"-Infinity\")\n   inspect!(1.5.atanh(), content=\"NaN\")\n   inspect!(@double.not_a_number.atanh(), content=\"NaN\")\n   inspect!(@double.infinity.atanh(), content=\"NaN\")\n   inspect!(@double.neg_infinity.atanh(), content=\"NaN\")\n }\n ```",
          "signature": "fn <a href=\"moonbitlang/core/double#Double\">Double</a>::atanh(self : Double) -> Double",
          "loc": {
            "path": "moonbitlang/core/double",
            "file": "hyperbolic_nonjs.mbt",
            "line": 355,
            "column": 8
          }
        },
        {
          "name": "cbrt",
          "docstring": "\n Calculates the cube root of a number.\n\n Parameters:\n\n * `self` : The number for which to calculate the cube root.\n\n Returns the cube root of `self`.\n\n Special Cases:\n\n * Return `NaN` if `self` is `NaN`.\n * Return `±0` if `self` is `±0`.\n * Return `Infinity` if `self` is `Infinity`.\n * Return `-Infinity` if `self` is `-Infinity`.\n\n Example\n\n ```moonbit\n test \"cbrt\" {\n   inspect!(1.0.cbrt(), content=\"1\")\n   inspect!(3.0.cbrt(), content=\"1.4422495703074083\")\n   inspect!((-3.0).cbrt(), content=\"-1.4422495703074083\")\n   inspect!(10.0.cbrt(), content=\"2.154434690031884\")\n   inspect!(1000.0.cbrt(), content=\"10\")\n   inspect!(@double.not_a_number.cbrt(), content=\"NaN\")\n   inspect!(@double.infinity, content=\"Infinity\")\n   inspect!(@double.neg_infinity, content=\"-Infinity\")\n }\n ```",
          "signature": "fn <a href=\"moonbitlang/core/double#Double\">Double</a>::cbrt(self : Double) -> Double",
          "loc": {
            "path": "moonbitlang/core/double",
            "file": "cbrt_nonjs.mbt",
            "line": 57,
            "column": 8
          }
        },
        {
          "name": "ceil",
          "docstring": "\n Returns the smallest integer greater than or equal to the given number.\n\n Parameters:\n\n * `self` : The floating point number to find the ceiling of.\n\n Returns the ceiling value of the input number.\n\n Example:\n\n ```moonbit\n test \"ceil\" {\n   inspect!(3.7.ceil(), content=\"4\")\n   inspect!((-3.7).ceil(), content=\"-3\")\n   inspect!(42.0.ceil(), content=\"42\")\n }\n ```",
          "signature": "fn <a href=\"moonbitlang/core/double#Double\">Double</a>::ceil(self : Double) -> Double",
          "loc": {
            "path": "moonbitlang/core/double",
            "file": "round_wasm.mbt",
            "line": 54,
            "column": 8
          }
        },
        {
          "name": "cos",
          "docstring": "\n Calculates the cosine of a number in radians. Handles special cases and edge\n conditions according to IEEE 754 standards.\n\n Parameters:\n\n * `x` : The angle in radians for which to calculate the cosine.\n\n Returns the cosine of the angle `x`.\n\n Example:\n\n ```moonbit\n test \"cos\" {\n   inspect!(0.0.cos(), content=\"1\")\n   inspect!(2.5.cos(), content=\"-0.8011436155469337\")\n   inspect!((-3.141592653589793).cos(), content=\"-1\") // -pi\n   inspect!((-5.0).cos(), content=\"0.28366218546322625\")\n   inspect!(31415926535897.9323846.cos(), content=\"0.9999992690101899\")\n   inspect!(@double.not_a_number.cos(), content=\"NaN\")\n   inspect!(@double.infinity.cos(), content=\"NaN\")\n   inspect!(@double.neg_infinity.cos(), content=\"NaN\")\n }\n ```",
          "signature": "fn <a href=\"moonbitlang/core/double#Double\">Double</a>::cos(self : Double) -> Double",
          "loc": {
            "path": "moonbitlang/core/double",
            "file": "trig_nonjs.mbt",
            "line": 734,
            "column": 8
          }
        },
        {
          "name": "cosh",
          "docstring": "\n Calculates the hyperbolic cosine of a number.\n\n Parameters:\n\n * `self` : The number for which to calculate the hyperbolic cosine.\n\n Returns the hyperbolic cosine of `self`.\n\n Special cases:\n\n * Returns `infinity` if `self` is `infinity`\n * Returns `NaN` if `self` is `NaN`\n\n Example\n\n ```moonbit\n test \"cosh\" {\n   inspect!(0.0.cosh(), content=\"1\")\n   inspect!((-0.0).cosh(), content=\"1\")\n   inspect!(1.0.cosh(), content=\"1.5430806348152437\")\n   inspect!(2.0.cosh(), content=\"3.7621956910836314\")\n   inspect!(1000.0.cosh(), content=\"Infinity\")\n   inspect!((-1000.0).cosh(), content=\"Infinity\")\n   inspect!(@double.not_a_number.cosh(), content=\"NaN\")\n   inspect!(@double.infinity.cosh(), content=\"Infinity\")\n   inspect!(@double.neg_infinity.cosh(), content=\"Infinity\")\n }\n ```",
          "signature": "fn <a href=\"moonbitlang/core/double#Double\">Double</a>::cosh(self : Double) -> Double",
          "loc": {
            "path": "moonbitlang/core/double",
            "file": "hyperbolic_nonjs.mbt",
            "line": 121,
            "column": 8
          }
        },
        {
          "name": "exp",
          "docstring": "\n Computes `e` raised to the power of a given number.\n\n Parameters:\n\n * `self` : The exponent value to compute `e^x`.\n\n Returns the value of `e^x`, where `e` is Euler's number (approximately\n 2.71828).\n\n Special cases:\n\n * Returns `x` if `x` is `infinity` (positive infinity)\n * Returns `0` if `x` is negative infinity\n * Returns `NaN` if `x` is `NaN`\n * Returns `1` if `x` is `0`\n\n Example:\n\n ```moonbit\n test \"exp\" {\n   inspect!(0.0.exp(), content=\"1\")\n   inspect!(1.0.exp(), content=\"2.718281828459045\")\n   inspect!((-1.0).exp(), content=\"0.36787944117144233\")\n   inspect!(not_a_number.exp().is_nan(), content=\"true\")\n }\n ```",
          "signature": "fn <a href=\"moonbitlang/core/double#Double\">Double</a>::exp(self : Double) -> Double",
          "loc": {
            "path": "moonbitlang/core/double",
            "file": "exp_nonjs.mbt",
            "line": 54,
            "column": 8
          }
        },
        {
          "name": "expm1",
          "docstring": "\n Calculates exp(x) - 1 accurately even when x is close to zero.\n\n Parameters:\n\n * `self` : The exponent.\n\n Returns e raised to the power of `self`, minus 1.\n\n Special Cases:\n\n * Returns NaN if `self` is NaN.\n * Returns -1 if `self` is negative infinity.\n * Returns `Infinity` if `self` is positive infinity.\n\n Example\n\n ```moonbit\n test \"expm1\" {\n   inspect!(0.0.expm1(), content=\"0\")\n   inspect!(1.0.expm1(), content=\"1.718281828459045\")\n   inspect!(2.0.expm1(), content=\"6.38905609893065\")\n   inspect!((-1.0).expm1(), content=\"-0.6321205588285577\")\n   inspect!((-2.0).expm1(), content=\"-0.8646647167633873\")\n   inspect!(@double.not_a_number.expm1(), content=\"NaN\")\n   inspect!(@double.infinity.expm1(), content=\"Infinity\")\n   inspect!(@double.neg_infinity.expm1(), content=\"-1\")\n }\n ```",
          "signature": "fn <a href=\"moonbitlang/core/double#Double\">Double</a>::expm1(self : Double) -> Double",
          "loc": {
            "path": "moonbitlang/core/double",
            "file": "exp_nonjs.mbt",
            "line": 192,
            "column": 8
          }
        },
        {
          "name": "floor",
          "docstring": "\n Returns the largest integer less than or equal to the given number.\n\n Parameters:\n\n * `number` : A floating-point number to be rounded down.\n\n Returns a double-precision floating-point number representing the largest\n integer less than or equal to the input.\n\n Example:\n\n ```moonbit\n test \"floor\" {\n   inspect!(3.7.floor(), content=\"3\")\n   inspect!((-3.7).floor(), content=\"-4\")\n   inspect!(0.0.floor(), content=\"0\")\n }\n ```",
          "signature": "fn <a href=\"moonbitlang/core/double#Double\">Double</a>::floor(self : Double) -> Double",
          "loc": {
            "path": "moonbitlang/core/double",
            "file": "round_wasm.mbt",
            "line": 75,
            "column": 8
          }
        },
        {
          "name": "from_int",
          "docstring": "\n Converts an integer to a double-precision floating-point number.\n\n Parameters:\n\n * `integer` : The integer value to be converted.\n\n Returns a double-precision floating-point number representing the given\n integer value.\n\n Example:\n\n ```moonbit\n test \"Double::from_int\" {\n   inspect!(@double.from_int(42), content=\"42\")\n   inspect!(@double.from_int(-1), content=\"-1\")\n }\n ```",
          "signature": "fn <a href=\"moonbitlang/core/double#Double\">Double</a>::from_int(i : Int) -> Double",
          "loc": {
            "path": "moonbitlang/core/double",
            "file": "double.mbt",
            "line": 51,
            "column": 16
          }
        },
        {
          "name": "hypot",
          "docstring": "\n Calculates the the square root of the sum of the squares of its arguments.\n\n Parameters:\n\n * `self` : The number to be used as the first argument.\n * `y` : The number to be used as the second argument.\n\n Returns the hypotenuse of a right-angled triangle whose legs are `self` and `y`.\n\n Example:\n\n ```moonbit\n test \"hypot\" {\n   inspect!(3.0.hypot(4.0), content=\"5\")\n   inspect!(5.0.hypot(12.0), content=\"13\")\n   inspect!(8.0.hypot(15.0), content=\"17\")\n   inspect!(7.0.hypot(24.0), content=\"25\")\n   inspect!(@double.not_a_number.hypot(1.0), content=\"NaN\")\n   inspect!(1.0.hypot(@double.not_a_number), content=\"NaN\")\n   inspect!(@double.infinity.hypot(1.0), content=\"Infinity\")\n   inspect!(1.0.hypot(@double.infinity), content=\"Infinity\")\n   inspect!(@double.neg_infinity.hypot(1.0), content=\"Infinity\")\n   inspect!(1.0.hypot(@double.neg_infinity), content=\"Infinity\")\n }\n ```",
          "signature": "fn <a href=\"moonbitlang/core/double#Double\">Double</a>::hypot(self : Double, y : Double) -> Double",
          "loc": {
            "path": "moonbitlang/core/double",
            "file": "hypot_nonjs.mbt",
            "line": 49,
            "column": 8
          }
        },
        {
          "name": "inf",
          "docstring": "\n Returns positive infinity if sign >= 0, negative infinity if sign < 0.",
          "signature": "fn <a href=\"moonbitlang/core/double#Double\">Double</a>::inf(sign : Int) -> Double",
          "loc": {
            "path": "moonbitlang/core/double",
            "file": "double.mbt",
            "line": 124,
            "column": 16
          }
        },
        {
          "name": "is_close",
          "docstring": "\n Determines whether two floating-point numbers are approximately equal within\n specified tolerances.\n The implementation follows the algorithm described in PEP 485 for Python's\n `math.isclose()`.\n\n Parameters:\n\n * `self` : The first floating-point number to compare.\n * `other` : The second floating-point number to compare.\n * `relative_tolerance` : The relative tolerance for the comparison. Must be\n non-negative. Defaults to 1e-9.\n * `absolute_tolerance` : The absolute tolerance for the comparison. Must be\n non-negative. Defaults to 0.0.\n\n Returns whether the two numbers are considered approximately equal. Returns\n `true` if the numbers are exactly equal or if they are within either the\n relative or absolute tolerance. Returns `false` if either number is infinite.\n\n Example:\n\n ```moonbit\n test \"is_close\" {\n   let x = 1.0\n   let y = 1.000000001\n   inspect!(x.is_close(y), content=\"false\")\n   inspect!(x.is_close(y, relative_tolerance=1.0e-10), content=\"false\")\n   inspect!(infinity.is_close(infinity), content=\"true\")\n }\n ```",
          "signature": "fn <a href=\"moonbitlang/core/double#Double\">Double</a>::is_close(self : Double, other : Double, relative_tolerance~ : Double = .., absolute_tolerance~ : Double = ..) -> Bool",
          "loc": {
            "path": "moonbitlang/core/double",
            "file": "double.mbt",
            "line": 379,
            "column": 8
          }
        },
        {
          "name": "is_inf",
          "docstring": "\n Checks whether a double-precision floating-point number represents positive\n or negative infinity.\n\n Parameters:\n\n * `value` : The double-precision floating-point number to check.\n\n Returns `true` if the value is either positive or negative infinity, `false`\n otherwise.\n\n Example:\n\n ```moonbit\n test \"is_inf\" {\n   inspect!(infinity.is_inf(), content=\"true\")\n   inspect!(neg_infinity.is_inf(), content=\"true\")\n   inspect!(42.0.is_inf(), content=\"false\")\n }\n ```",
          "signature": "fn <a href=\"moonbitlang/core/double#Double\">Double</a>::is_inf(self : Double) -> Bool",
          "loc": {
            "path": "moonbitlang/core/double",
            "file": "double.mbt",
            "line": 198,
            "column": 8
          }
        },
        {
          "name": "is_nan",
          "docstring": "\n Checks whether a double-precision floating-point number represents a \"Not a\n Number\" (NaN) value.\n\n Parameters:\n\n * `number` : A double-precision floating-point value to be checked.\n\n Returns `true` if the number is NaN, `false` otherwise.\n\n Example:\n\n ```moonbit\n test \"is_nan\" {\n   inspect!(not_a_number.is_nan(), content=\"true\")\n   inspect!(42.0.is_nan(), content=\"false\")\n   inspect!((0.0 / 0.0).is_nan(), content=\"true\")\n }\n ```",
          "signature": "fn <a href=\"moonbitlang/core/double#Double\">Double</a>::is_nan(self : Double) -> Bool",
          "loc": {
            "path": "moonbitlang/core/double",
            "file": "double.mbt",
            "line": 173,
            "column": 8
          }
        },
        {
          "name": "is_neg_inf",
          "docstring": "\n Checks whether a double-precision floating-point number is negative infinity.\n\n Parameters:\n\n * `self` : The double-precision floating-point number to check.\n\n Returns a boolean value indicating whether the number is negative infinity.\n\n Example:\n\n ```moonbit\n test \"is_neg_inf\" {\n   inspect!((-1.0 / 0.0).is_neg_inf(), content=\"true\")\n   inspect!(42.0.is_neg_inf(), content=\"false\")\n   inspect!((1.0 / 0.0).is_neg_inf(), content=\"false\") // positive infinity\n }\n ```",
          "signature": "fn <a href=\"moonbitlang/core/double#Double\">Double</a>::is_neg_inf(self : Double) -> Bool",
          "loc": {
            "path": "moonbitlang/core/double",
            "file": "double.mbt",
            "line": 242,
            "column": 8
          }
        },
        {
          "name": "is_pos_inf",
          "docstring": "\n Checks whether a double-precision floating-point number is positive infinity.\n\n Parameters:\n\n * `value` : The double-precision floating-point number to check.\n\n Returns `true` if the number is positive infinity, `false` otherwise.\n\n Example:\n\n ```moonbit\n test \"is_pos_inf\" {\n   inspect!(infinity.is_pos_inf(), content=\"true\")\n   inspect!(neg_infinity.is_pos_inf(), content=\"false\")\n   inspect!(42.0.is_pos_inf(), content=\"false\")\n }\n ```",
          "signature": "fn <a href=\"moonbitlang/core/double#Double\">Double</a>::is_pos_inf(self : Double) -> Bool",
          "loc": {
            "path": "moonbitlang/core/double",
            "file": "double.mbt",
            "line": 220,
            "column": 8
          }
        },
        {
          "name": "ln",
          "docstring": "\n Calculates the natural logarithm of a double-precision floating-point number.\n\n Parameters:\n\n * `self`: The input number.\n\n Returns the natural logarithm of the input number, with the following special\n cases:\n\n * Returns NaN if the input is NaN or negative\n * Returns negative infinity if the input is zero\n * Returns the input if it is positive infinity\n\n Example:\n\n ```moonbit\n test \"ln\" {\n   inspect!(2.0.ln(), content=\"0.6931471805599453\")\n   inspect!(1.0.ln(), content=\"0\")\n   inspect!((-1.0).ln(), content=\"NaN\")\n   inspect!(0.0.ln(), content=\"-Infinity\")\n }\n ```",
          "signature": "fn <a href=\"moonbitlang/core/double#Double\">Double</a>::ln(self : Double) -> Double",
          "loc": {
            "path": "moonbitlang/core/double",
            "file": "log_nonjs.mbt",
            "line": 106,
            "column": 8
          }
        },
        {
          "name": "ln_1p",
          "docstring": "\n Calculates ln(1 + x) accurately even when x is close to zero.\n\n Parameters:\n\n * `self` : The number to which 1 is added before calculating the logarithm.\n\n Returns the natural logarithm of 1 + `self`.\n\n Special Cases:\n\n * Returns `NaN` if `self` is `NaN` or less than -1.\n * Returns `-Infinity` if `self` is -1.\n * Returns `+Infinity` if `self` is `+Infinity`.\n\n Example:\n\n ```moonbit\n test \"ln_1p\" {\n   inspect!(0.0.ln_1p(), content=\"0\")\n   inspect!(1.0.ln_1p(), content=\"0.6931471805599453\")\n   inspect!(2.0.ln_1p(), content=\"1.0986122886681096\")\n   inspect!(@double.not_a_number.ln_1p(), content=\"NaN\")\n   inspect!((-1.0).ln_1p(), content=\"-Infinity\")\n   inspect!((-2.0).ln_1p(), content=\"NaN\")\n   inspect!(@double.infinity.ln_1p(), content=\"Infinity\")\n   inspect!(@double.neg_infinity.ln_1p(), content=\"NaN\")\n }\n ```",
          "signature": "fn <a href=\"moonbitlang/core/double#Double\">Double</a>::ln_1p(self : Double) -> Double",
          "loc": {
            "path": "moonbitlang/core/double",
            "file": "log_nonjs.mbt",
            "line": 228,
            "column": 8
          }
        },
        {
          "name": "log10",
          "docstring": "\n Calculates the base-10 logarithm of a double-precision floating-point number.\n\n Parameters:\n\n * `self` : The double-precision floating-point number to calculate the\n logarithm of.\n\n Returns a double-precision floating-point number representing the base-10\n logarithm of the input.\n\n Example:\n\n ```moonbit\n test \"log10\" {\n   inspect!(0.1.log10(), content=\"-1\")\n   inspect!(1.0.log10(), content=\"0\")\n   inspect!(10.0.log10(), content=\"1\")\n   inspect!(100.0.log10(), content=\"2\")\n   inspect!(15.0.log10(), content=\"1.1760912590556813\")\n }\n ```",
          "signature": "fn <a href=\"moonbitlang/core/double#Double\">Double</a>::log10(self : Double) -> Double",
          "loc": {
            "path": "moonbitlang/core/double",
            "file": "log_nonjs.mbt",
            "line": 178,
            "column": 8
          }
        },
        {
          "name": "log2",
          "docstring": "\n Calculates the base-2 logarithm of a double-precision floating-point number.\n\n Parameters:\n\n * `x` : A double-precision floating-point number.\n\n Returns the base-2 logarithm of the input number.\n\n Example:\n\n ```moonbit\n test \"log2\" {\n   inspect!(2.0.log2(), content=\"1\")\n   inspect!(0.5.log2(), content=\"-1\")\n   inspect!(3.0.log2(), content=\"1.584962500721156\")\n }\n ```",
          "signature": "fn <a href=\"moonbitlang/core/double#Double\">Double</a>::log2(self : Double) -> Double",
          "loc": {
            "path": "moonbitlang/core/double",
            "file": "log_nonjs.mbt",
            "line": 148,
            "column": 8
          }
        },
        {
          "name": "min_normal",
          "docstring": "\n Returns the smallest positive normal value of a double-precision\n floating-point number.\n\n Returns a `Double` value that represents the smallest positive normal number\n that can be represented by a double-precision floating-point number\n (approximately 2.2250738585072014e-308).\n\n Example:\n\n ```moonbit\n test \"Double::min_normal\" {\n   inspect!(@double.min_positive, content=\"2.2250738585072014e-308\")\n }\n ```\n",
          "signature": "fn <a href=\"moonbitlang/core/double#Double\">Double</a>::min_normal() -> Double",
          "loc": {
            "path": "moonbitlang/core/double",
            "file": "double.mbt",
            "line": 150,
            "column": 16
          }
        },
        {
          "name": "nan",
          "docstring": "\n \\[DEPRECATED] Returns a \"not-a-number\" (NaN) value.\n\n This function is deprecated. Use `@double.not_a_number` instead.\n\n Returns a double-precision floating-point NaN value.\n\n Example:\n\n ```moonbit\n test \"Double::nan\" {\n   let nan = @double.not_a_number\n   inspect!(nan.is_nan(), content=\"true\")\n }\n ```\n",
          "signature": "fn <a href=\"moonbitlang/core/double#Double\">Double</a>::nan() -> Double",
          "loc": {
            "path": "moonbitlang/core/double",
            "file": "double.mbt",
            "line": 116,
            "column": 16
          }
        },
        {
          "name": "pow",
          "docstring": "\n Calculates the power of a number by raising the base to the specified\n exponent. Handles special cases and edge conditions according to IEEE 754\n standards.\n\n Parameters:\n\n * `base` : The base number to be raised to a power.\n * `exponent` : The power to raise the base number to.\n\n Returns the result of raising `base` to the power of `exponent`.\n\n Example:\n\n ```moonbit\n test \"pow\" {\n   let x = 2.0\n   inspect!(x.pow(3.0), content=\"8\")\n   inspect!(x.pow(0.5), content=\"1.4142135623730951\")\n   inspect!(x.pow(0.0), content=\"1\")\n   inspect!((-1.0).pow(2.0), content=\"1\")\n   inspect!(0.0.pow(0.0), content=\"1\")\n   inspect!(infinity.pow(-1.0), content=\"0\")\n }\n ```",
          "signature": "fn <a href=\"moonbitlang/core/double#Double\">Double</a>::pow(self : Double, other : Double) -> Double",
          "loc": {
            "path": "moonbitlang/core/double",
            "file": "pow_nonjs.mbt",
            "line": 135,
            "column": 8
          }
        },
        {
          "name": "round",
          "docstring": "\n Rounds a floating-point number to the nearest integer using \"round half up\"\n rule. In this rule, when a number is halfway between two integers (like 3.5),\n it is rounded up to the next integer.\n\n Parameters:\n\n * `value` : The floating-point number to be rounded.\n\n Returns the rounded value as a double-precision floating-point number.\n\n Example:\n\n ```moonbit\n test \"round\" {\n   inspect!(3.7.round(), content=\"4\")\n   inspect!(3.2.round(), content=\"3\")\n   inspect!(3.5.round(), content=\"4\")\n   inspect!((-3.5).round(), content=\"-3\")\n }\n ```",
          "signature": "fn <a href=\"moonbitlang/core/double#Double\">Double</a>::round(self : Double) -> Double",
          "loc": {
            "path": "moonbitlang/core/double",
            "file": "round_wasm.mbt",
            "line": 98,
            "column": 8
          }
        },
        {
          "name": "signum",
          "docstring": "\n Returns the sign of the double.\n - If the double is positive, returns 1.0.\n - If the double is negative, returns -1.0.\n - Otherwise, returns the double itself (0.0, -0.0 and NaN).",
          "signature": "fn <a href=\"moonbitlang/core/double#Double\">Double</a>::signum(self : Double) -> Double",
          "loc": {
            "path": "moonbitlang/core/double",
            "file": "double.mbt",
            "line": 88,
            "column": 8
          }
        },
        {
          "name": "sin",
          "docstring": "\n Calculates the sine of a number in radians. Handles special cases and edge\n conditions according to IEEE 754 standards.\n\n Parameters:\n\n * `x` : The angle in radians for which to calculate the sine.\n\n Returns the sine of the angle `x`.\n\n Example:\n\n ```moonbit\n test \"sin\" {\n   inspect!(0.0.sin(), content=\"0\")\n   inspect!(1.570796326794897.sin(), content=\"1\") // pi / 2\n   inspect!(2.0.sin(), content=\"0.9092974268256817\")\n   inspect!(-5.0.sin(), content=\"0.9589242746631385\")\n   inspect!(31415926535897.9323846.sin(), content=\"0.0012091232715481885\")\n   inspect!(@double.not_a_number.sin(), content=\"NaN\")\n   inspect!(@double.infinity.sin(), content=\"NaN\")\n   inspect!(@double.neg_infinity.sin(), content=\"NaN\")\n }\n ```",
          "signature": "fn <a href=\"moonbitlang/core/double#Double\">Double</a>::sin(self : Double) -> Double",
          "loc": {
            "path": "moonbitlang/core/double",
            "file": "trig_nonjs.mbt",
            "line": 691,
            "column": 8
          }
        },
        {
          "name": "sinh",
          "docstring": "\n Calculates the hyperbolic sine of a number.\n\n Parameters:\n\n * `self` : The number for which to calculate the hyperbolic sine.\n\n Returns the hyperbolic sine of `self`.\n\n Special cases:\n\n * Returns `infinity` if `self` is `infinity`\n * Returns `NaN` if `self` is `NaN`\n\n Example:\n\n ```moonbit\n test \"sinh\" {\n   inspect!(0.0.sinh(), content=\"0\")\n   inspect!((-0.0).sinh(), content=\"0\")\n   inspect!(1.0.sinh(), content=\"1.1752011936438014\")\n   inspect!(2.0.sinh(), content=\"3.626860407847019\")\n   inspect!(1000.0.sinh(), content=\"Infinity\")\n   inspect!((-1000.0).sinh(), content=\"-Infinity\")\n   inspect!(@double.not_a_number.sinh(), content=\"NaN\")\n   inspect!(@double.infinity.sinh(), content=\"Infinity\")\n   inspect!(@double.neg_infinity.sinh(), content=\"-Infinity\")\n }\n ```",
          "signature": "fn <a href=\"moonbitlang/core/double#Double\">Double</a>::sinh(self : Double) -> Double",
          "loc": {
            "path": "moonbitlang/core/double",
            "file": "hyperbolic_nonjs.mbt",
            "line": 61,
            "column": 8
          }
        },
        {
          "name": "tan",
          "docstring": "\n Calculates the tangent of a number in radians. Handles special cases and edge\n conditions according to IEEE 754 standards.\n\n Parameters:\n\n * `x` : The angle in radians for which to calculate the tangent.\n\n Returns the tangent of the angle `x`.\n\n Example:\n\n ```moonbit\n test \"tan\" {\n   inspect!(0.0.tan(), content=\"0\")\n   inspect!(0.7853981633974483.tan(), content=\"0.9999999999999999\")\n   inspect!(4.0.tan(), content=\"1.1578212823495777\")\n   inspect!(5.0.tan(), content=\"-3.380515006246586\")\n   inspect!(31415926535897.9323846.tan(), content=\"0.0012091241554056254\")\n   inspect!(@double.not_a_number.tan(), content=\"NaN\")\n   inspect!(@double.infinity.tan(), content=\"NaN\")\n   inspect!(@double.neg_infinity.tan(), content=\"NaN\")\n }\n ```",
          "signature": "fn <a href=\"moonbitlang/core/double#Double\">Double</a>::tan(self : Double) -> Double",
          "loc": {
            "path": "moonbitlang/core/double",
            "file": "trig_nonjs.mbt",
            "line": 777,
            "column": 8
          }
        },
        {
          "name": "tanh",
          "docstring": "\n Calculates the hyperbolic tangent of a number.\n\n Parameters:\n\n * `self` : The number for which to calculate the hyperbolic tangent.\n\n Returns the hyperbolic tangent of `self`.\n\n Special cases:\n\n * Returns `NaN` if `self` is `NaN`\n * Returns `1` if `self` is `infinity`\n * Returns `-1` if `self` is `-infinity`\n\n Example\n\n ```moobit\n test \"tanh\" {\n   inspect!(0.0.tanh(), content=\"0\")\n   inspect!((-0.0).tanh(), content=\"0\")\n   inspect!(1.0.tanh(), content=\"0.7615941559557649\")\n   inspect!(2.0.tanh(), content=\"0.9640275800758169\")\n   inspect!(1000.0.tanh(), content=\"1\")\n   inspect!((-1000.0).tanh(), content=\"-1\")\n   inspect!(@double.not_a_number.tanh(), content=\"NaN\")\n   inspect!(@double.infinity.tanh(), content=\"1\")\n   inspect!(@double.neg_infinity.tanh(), content=\"-1\")\n }\n ```",
          "signature": "fn <a href=\"moonbitlang/core/double#Double\">Double</a>::tanh(self : Double) -> Double",
          "loc": {
            "path": "moonbitlang/core/double",
            "file": "hyperbolic_nonjs.mbt",
            "line": 183,
            "column": 8
          }
        },
        {
          "name": "to_be_bytes",
          "docstring": "\n Converts a double-precision floating-point number to a sequence of bytes in\n big-endian byte order (most significant byte first).\n\n Parameters:\n\n * `self` : The double-precision floating-point number to be converted.\n\n Returns a sequence of 8 bytes representing the double-precision\n floating-point number in big-endian byte order.\n\n Example:\n\n ```moonbit\n test \"to_be_bytes\" {\n   let d = 1.0\n   inspect!(d.to_be_bytes(), content=\n   #|b\"\\x3f\\xf0\\x00\\x00\\x00\\x00\\x00\\x00\"\n )\n }\n ```",
          "signature": "fn <a href=\"moonbitlang/core/double#Double\">Double</a>::to_be_bytes(self : Double) -> Bytes",
          "loc": {
            "path": "moonbitlang/core/double",
            "file": "double.mbt",
            "line": 423,
            "column": 8
          }
        },
        {
          "name": "to_le_bytes",
          "docstring": "\n Converts a double-precision floating-point number to a sequence of bytes in\n little-endian order (least significant byte first).\n\n Parameters:\n\n * `self` : A double-precision floating-point number to be converted.\n\n Returns a sequence of 8 bytes representing the double-precision\n floating-point number in little-endian order.\n\n Example:\n\n ```moonbit\n test \"to_le_bytes\" {\n   let d = 1.0\n   inspect!(d.to_le_bytes(), content=\n   #|b\"\\x00\\x00\\x00\\x00\\x00\\x00\\xf0\\x3f\"\n )\n }\n ```",
          "signature": "fn <a href=\"moonbitlang/core/double#Double\">Double</a>::to_le_bytes(self : Double) -> Bytes",
          "loc": {
            "path": "moonbitlang/core/double",
            "file": "double.mbt",
            "line": 448,
            "column": 8
          }
        },
        {
          "name": "to_string",
          "docstring": "\n Converts a double-precision floating-point number to its string\n representation.\n\n Parameters:\n\n * `self`: The double-precision floating-point number to be converted.\n\n Returns a string representation of the double-precision floating-point\n number.\n\n Example:\n\n ```moonbit\n test \"Double::to_string\" {\n   inspect!(42.0.to_string(), content=\"42\")\n   inspect!(3.14159.to_string(), content=\"3.14159\")\n   inspect!((-0.0).to_string(), content=\"0\")\n   inspect!(not_a_number.to_string(), content=\"NaN\")\n }\n ```\n",
          "signature": "fn <a href=\"moonbitlang/core/double#Double\">Double</a>::to_string(self : Double) -> String",
          "loc": {
            "path": "moonbitlang/core/double",
            "file": "double.mbt",
            "line": 340,
            "column": 8
          }
        },
        {
          "name": "to_uint",
          "docstring": "\n Converts a double-precision floating-point number to a 32-bit unsigned\n integer. Handles special cases including NaN and numbers outside the valid\n `UInt` range.\n\n Parameters:\n\n * `self` : The double-precision floating-point number to be converted.\n\n Returns an 32-bit unsigned integer value according to the following rules:\n\n * Returns 0 if the input is NaN\n * Returns `@uint.max_value` (4294967295U) if the input is greater than or\n   equal to `@uint.max_value`\n * Returns `@uint.min_value` (0U) if the input is less than or equal\n   to `@uint.min_value`\n * Otherwise returns the integer part of the input by truncating towards zero\n\n Example:\n\n ```moonbit\n test \"Double::to_uint/normal\" {\n   inspect!(42.0.to_uint(), content=\"42\")\n   inspect!((-42.5).to_uint(), content=\"0\")\n   inspect!((0.0 / 0.0).to_uint(), content=\"0\") // NaN\n   inspect!((1.0 / 0.0).to_uint(), content=\"4294967295\") // Infinity\n   inspect!((-1.0 / 0.0).to_uint(), content=\"0\") // -Infinity\n }\n ```",
          "signature": "fn <a href=\"moonbitlang/core/double#Double\">Double</a>::to_uint(self : Double) -> UInt",
          "loc": {
            "path": "moonbitlang/core/double",
            "file": "to_uint_wasm.mbt",
            "line": 44,
            "column": 8
          }
        },
        {
          "name": "trunc",
          "docstring": "\n Returns an integer value by discarding the decimal part of the floating-point\n number (truncation toward zero).\n\n Parameters:\n\n * `self` : The floating-point number to be truncated.\n\n Returns a floating-point number representing the integer part of the input.\n\n Example:\n\n ```moonbit\n test \"trunc\" {\n   inspect!(3.7.trunc(), content=\"3\")\n   inspect!((-3.7).trunc(), content=\"-3\")\n   inspect!(0.0.trunc(), content=\"0\")\n }\n ```",
          "signature": "fn <a href=\"moonbitlang/core/double#Double\">Double</a>::trunc(self : Double) -> Double",
          "loc": {
            "path": "moonbitlang/core/double",
            "file": "round_wasm.mbt",
            "line": 34,
            "column": 8
          }
        }
      ]
    }
  ]
}