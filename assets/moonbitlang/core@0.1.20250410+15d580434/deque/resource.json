{
  "kind": "package",
  "relative_path": "deque",
  "module_path": "moonbitlang/core",
  "readme_content": "---\nmoonbit : true\n---\n\n# Deque\n\nDeque is a double-ended queue implemented as a round-robin queue, supporting O(1) head or tail insertion and querying, just like double-ended queues in other languages(C++ std::deque / Rust VecDeque), here deque also supports random access.\n\n# Usage\n\n## Create\n\nYou can create a deque manually via the `new()` or construct it using the `of()`.\n\n```moonbit\ntest {\n    let _dv : @deque.T[Int] = @deque.new()\n    let _dv = @deque.of([1, 2, 3, 4, 5])\n}\n```\n\nIf you want to set the length at creation time to minimize expansion consumption, you can add parameter `capacity` to the `new()` function.\n\n```moonbit\ntest {\n    let _dv: @deque.T[Int] = @deque.new(capacity=10)\n}\n```\n\n## Length & Capacity\n\nA deque is an indefinite-length, auto-expandable datatype. You can use `length()` to get the number of elements in the current queue, or `capacity()` to get the current capacity.\n\n```moonbit\ntest {\n   let dv = @deque.of([1, 2, 3, 4, 5])\n   assert_eq!(dv.length(), 5)\n   assert_eq!(dv.capacity(), 5)\n}\n```\nSimilarly, you can use the `is_empty` to determine whether the queue is empty.\n\n```moonbit\ntest {\n   let dv : @deque.T[Int] = @deque.new()\n   assert_eq!(dv.is_empty(), true)\n}\n```\nYou can use `reserve_capacity` to reserve capacity, ensures that it can hold at least the number of elements\nspecified by the `capacity` argument.\n\n```moonbit\ntest {\n  let dv = @deque.of([1])\n  dv.reserve_capacity(10)\n  assert_eq!(dv.capacity(), 10)\n}\n```\n\nAlso, you can use `shrink_to_fit` to shrink the capacity of the deque.\n\n```moonbit\ntest {\n  let dv = @deque.new(capacity=10)\n  dv.push_back(1)\n  dv.push_back(2)\n  dv.push_back(3)\n  assert_eq!(dv.capacity(), 10)\n  dv.shrink_to_fit()\n  assert_eq!(dv.capacity(), 3)\n}\n```\n\n## Front & Back & Get\n\nYou can use `front()` and `back()` to get the head and tail elements of the queue, respectively. Since the queue may be empty, their return values are both `Option`, or `None` if the queue is empty.\n\n```moonbit\ntest {\n  let dv = @deque.of([1, 2, 3, 4, 5])\n  assert_eq!(dv.front(), Some(1))\n  assert_eq!(dv.back(), Some(5))\n}\n```\n\nYou can also use `op_get` to access elements of the queue directly, but be careful not to cross the boundaries!\n\n```moonbit\ntest {\n  let dv = @deque.of([1, 2, 3, 4, 5])\n  assert_eq!(dv[0], 1)\n  assert_eq!(dv[4], 5)\n}\n```\n\n## Push & Set\n\nSince the queue is bi-directional, you can use `push_front()` and `push_back()` to add values to the head or tail of the queue, respectively.\n\n```moonbit\ntest {\n  let dv = @deque.of([1, 2, 3, 4, 5])\n  dv.push_front(6)\n  dv.push_front(7)\n  dv.push_back(8)\n  dv.push_back(9)\n  //now: 6 7 1 2 3 4 5 8 9\n}\n```\n\nYou can also use `op_set` to set elements of the queue directly, but be careful not to cross the boundaries!\n\n```moonbit\ntest {\n  let dv = @deque.of([1, 2, 3, 4, 5])\n  dv[0] = 5\n  assert_eq!(dv[0], 5)\n}\n```\n\n## Pop\n\nYou can use `pop_front()` and `pop_back()` to pop the element at the head or tail of the queue, respectively, and like [Front & Back](#Front & Back & Get), their return values are `Option`, loaded with the value of the element being popped.\n\n```moonbit\ntest {\n  let dv = @deque.of([1, 2, 3, 4, 5])\n  let _back = dv.pop_back() // Some(5)\n  assert_eq!(dv.back(), Some(4))\n  let _front = dv.pop_front() //Some(1)\n  assert_eq!(dv.front(), Some(2))\n  assert_eq!(dv.length(), 3)\n}\n```    \nIf you only want to pop an element without getting the return value, you can use `unsafe_pop_front()` with `unsafe_pop_back()`. These two functions will panic if the queue is empty.\n\n```moonbit\ntest {\n  let dv = @deque.of([1, 2, 3, 4, 5])\n  dv.unsafe_pop_front()\n  assert_eq!(dv.front(), Some(2))\n  dv.unsafe_pop_back()\n  assert_eq!(dv.back(), Some(4))\n}\n```\n\n## Clear\n\nYou can use `clear` to clear a deque. But note that the memory it already occupies does not change.\n\n```moonbit\ntest {\n  let dv = @deque.of([1, 2, 3, 4, 5])\n  dv.clear()\n  assert_eq!(dv.is_empty(), true)\n}\n```\n\n## Equal\n\ndeque supports comparing them directly using `op_equal`.\n\n```moonbit\ntest {\n  let dqa = @deque.of([1, 2, 3, 4, 5])\n  let dqb = @deque.of([1, 2, 3, 4, 5])\n  assert_eq!(dqa, dqb)\n}\n```\n\n## Iter & Map\n\ndeque supports vector-like `iter/iteri/map/mapi` functions and their inverse forms.\n\n```moonbit\ntest {\n  let dv = @deque.of([1, 2, 3, 4, 5])\n  let arr = []\n  dv.each(fn(elem) { arr.push(elem) })\n  assert_eq!(arr, [1, 2, 3, 4, 5])\n  let arr2 = []\n  dv.eachi(fn(i, _elem) { arr2.push(i) })\n  assert_eq!(arr2, [0, 1, 2, 3, 4])\n  let arr3 = []\n  let _ = dv.map(fn(elem) { arr3.push(elem + 1) })\n  assert_eq!(arr3, [2, 3, 4, 5, 6])\n  let arr4 = []\n  let _ = dv.mapi(fn(i, elem) { arr4.push(elem + i) })\n  assert_eq!(arr4, [1, 3, 5, 7, 9])\n}\n```\n\n## Search & Contains\n\nYou can use `contains()` to find out if a value is in the deque, or `search()` to find its index in the deque.\n\n```moonbit\ntest {\n  let dv = @deque.of([1, 2, 3, 4, 5])\n  assert_eq!(dv.contains(1), true)\n  assert_eq!(dv.contains(6), false)\n  assert_eq!(dv.search(1), Some(0))\n  assert_eq!(dv.search(6), None)\n}\n```\n",
  "package_data": "moonbitlang/core/deque/package_data.json",
  "source_files": [ "types.mbt", "deque.mbt" ]
}