{
  "name": "moonbitlang/core/immut/list",
  "traits": [],
  "types": [
    {
      "name": "T",
      "docstring": "",
      "signature": "pub(all) enum T[A] {\n  Nil\n  Cons(A, <a href=\"moonbitlang/core/immut/list#T\">T</a>[A])\n}",
      "loc": {
        "path": "moonbitlang/core/immut/list",
        "file": "types.mbt",
        "line": 16,
        "column": 15
      },
      "methods": [
        {
          "name": "add",
          "docstring": "",
          "signature": "fn <a href=\"moonbitlang/core/immut/list#T\">T</a>::add[A](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A], head : A) -> <a href=\"moonbitlang/core/immut/list#T\">T</a>[A]",
          "loc": {
            "path": "moonbitlang/core/immut/list",
            "file": "list.mbt",
            "line": 16,
            "column": 8
          }
        },
        {
          "name": "all",
          "docstring": "\n Test if all elements of the list satisfy the predicate.",
          "signature": "fn <a href=\"moonbitlang/core/immut/list#T\">T</a>::all[A](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A], f : (A) -> Bool) -> Bool",
          "loc": {
            "path": "moonbitlang/core/immut/list",
            "file": "list.mbt",
            "line": 209,
            "column": 8
          }
        },
        {
          "name": "any",
          "docstring": "\n Test if any element of the list satisfies the predicate.",
          "signature": "fn <a href=\"moonbitlang/core/immut/list#T\">T</a>::any[A](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A], f : (A) -> Bool) -> Bool",
          "loc": {
            "path": "moonbitlang/core/immut/list",
            "file": "list.mbt",
            "line": 218,
            "column": 8
          }
        },
        {
          "name": "concat",
          "docstring": "\n Concatenate two lists.\n\n # Example\n\n ```\n let ls = @list.of([1, 2, 3, 4, 5]).concat(@list.of([6, 7, 8, 9, 10]))\n assert_eq!(ls, @list.of([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]))\n ```",
          "signature": "fn <a href=\"moonbitlang/core/immut/list#T\">T</a>::concat[A](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A], other : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A]) -> <a href=\"moonbitlang/core/immut/list#T\">T</a>[A]",
          "loc": {
            "path": "moonbitlang/core/immut/list",
            "file": "list.mbt",
            "line": 307,
            "column": 8
          }
        },
        {
          "name": "concat_map",
          "docstring": "\n map over the list and concat all results.\n\n `concat_map(f, ls)` equal to `ls.map(f).fold(Nil, fn(acc, x) { acc.concat(x) })))`\n\n # Example\n\n ```\n let ls = @list.from_array([1, 2, 3])\n let r = ls.flat_map(fn(x) { @list.from_array([x, x * 2]) })\n assert_eq!(r, @list.from_array([1, 2, 2, 4, 3, 6]))\n ```",
          "signature": "fn <a href=\"moonbitlang/core/immut/list#T\">T</a>::concat_map[A, B](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A], f : (A) -> <a href=\"moonbitlang/core/immut/list#T\">T</a>[B]) -> <a href=\"moonbitlang/core/immut/list#T\">T</a>[B]",
          "loc": {
            "path": "moonbitlang/core/immut/list",
            "file": "list.mbt",
            "line": 498,
            "column": 8
          }
        },
        {
          "name": "contains",
          "docstring": "\n Check if the list contains the value.",
          "signature": "fn <a href=\"moonbitlang/core/immut/list#T\">T</a>::contains[A : <a href=\"moonbitlang/core/builtin#Eq\">Eq</a>](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A], value : A) -> Bool",
          "loc": {
            "path": "moonbitlang/core/immut/list",
            "file": "list.mbt",
            "line": 742,
            "column": 8
          }
        },
        {
          "name": "default",
          "docstring": "",
          "signature": "fn <a href=\"moonbitlang/core/immut/list#T\">T</a>::default[X]() -> <a href=\"moonbitlang/core/immut/list#T\">T</a>[X]",
          "loc": {
            "path": "moonbitlang/core/immut/list",
            "file": "deprecated.mbt",
            "line": 73,
            "column": 11
          }
        },
        {
          "name": "drop",
          "docstring": "\n Drop first n elements of the list.\n If the list is shorter than n, return an empty list.\n\n # Example\n\n ```\n let ls = @list.of([1, 2, 3, 4, 5])\n let r = ls.drop(3)\n assert_eq!(r, @list.of([4, 5]))\n ```",
          "signature": "fn <a href=\"moonbitlang/core/immut/list#T\">T</a>::drop[A](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A], n : Int) -> <a href=\"moonbitlang/core/immut/list#T\">T</a>[A]",
          "loc": {
            "path": "moonbitlang/core/immut/list",
            "file": "list.mbt",
            "line": 801,
            "column": 8
          }
        },
        {
          "name": "drop_while",
          "docstring": "\n Drop the longest prefix of a list of elements that satisfies a given predicate.\n\n # Example\n\n ```\n let ls = @list.from_array([1, 2, 3, 4])\n let r = ls.drop_while(fn(x) { x < 3 })\n assert_eq!(r, @list.of([3, 4]))\n ```",
          "signature": "fn <a href=\"moonbitlang/core/immut/list#T\">T</a>::drop_while[A](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A], p : (A) -> Bool) -> <a href=\"moonbitlang/core/immut/list#T\">T</a>[A]",
          "loc": {
            "path": "moonbitlang/core/immut/list",
            "file": "list.mbt",
            "line": 842,
            "column": 8
          }
        },
        {
          "name": "each",
          "docstring": "\n Iterates over the list.\n\n # Example\n\n ```\n let arr = []\n @list.of([1, 2, 3, 4, 5]).each(fn(x) { arr.push(x) })\n assert_eq!(arr, [1, 2, 3, 4, 5])\n ```",
          "signature": "fn <a href=\"moonbitlang/core/immut/list#T\">T</a>::each[A](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A], f : (A) -> Unit) -> Unit",
          "loc": {
            "path": "moonbitlang/core/immut/list",
            "file": "list.mbt",
            "line": 94,
            "column": 8
          }
        },
        {
          "name": "eachi",
          "docstring": "\n Iterates over the list with index.\n\n # Example\n\n ```\n let arr = []\n @list.of([1, 2, 3, 4, 5]).eachi(fn(i, x) { arr.push(\"(\\{i},\\{x})\") })\n assert_eq!(arr, [\"(0,1)\", \"(1,2)\", \"(2,3)\", \"(3,4)\", \"(4,5)\"])\n ```",
          "signature": "fn <a href=\"moonbitlang/core/immut/list#T\">T</a>::eachi[A](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A], f : (Int, A) -> Unit) -> Unit",
          "loc": {
            "path": "moonbitlang/core/immut/list",
            "file": "list.mbt",
            "line": 114,
            "column": 8
          }
        },
        {
          "name": "equal",
          "docstring": "\n Compares two lists for equality.\n\n # Example\n\n ```\n assert_eq!(@list.of([1, 2, 3]) == @list.of([1, 2, 3]), true)\n ```",
          "signature": "fn <a href=\"moonbitlang/core/immut/list#T\">T</a>::equal[A : <a href=\"moonbitlang/core/builtin#Eq\">Eq</a>](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A], other : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A]) -> Bool",
          "loc": {
            "path": "moonbitlang/core/immut/list",
            "file": "deprecated.mbt",
            "line": 55,
            "column": 8
          }
        },
        {
          "name": "filter",
          "docstring": "\n Filter the list.\n\n # Example\n\n ```\n assert_eq!(@list.of([1, 2, 3, 4, 5]).filter(fn(x){ x % 2 == 0}), @list.of([2, 4]))\n ```",
          "signature": "fn <a href=\"moonbitlang/core/immut/list#T\">T</a>::filter[A](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A], f : (A) -> Bool) -> <a href=\"moonbitlang/core/immut/list#T\">T</a>[A]",
          "loc": {
            "path": "moonbitlang/core/immut/list",
            "file": "list.mbt",
            "line": 195,
            "column": 8
          }
        },
        {
          "name": "filter_map",
          "docstring": "\n Map over the list and keep all `value`s for which the mapped result is `Some(value)`.\n\n # Example\n\n ```\n let ls = @list.of([4, 2, 2, 6, 3, 1])\n let r = ls.filter_map(fn(x) { if (x >= 3) { Some(x) } else { None } })\n assert_eq!(r, @list.of([4, 6, 3]))\n ```",
          "signature": "fn <a href=\"moonbitlang/core/immut/list#T\">T</a>::filter_map[A, B](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A], f : (A) -> B?) -> <a href=\"moonbitlang/core/immut/list#T\">T</a>[B]",
          "loc": {
            "path": "moonbitlang/core/immut/list",
            "file": "list.mbt",
            "line": 531,
            "column": 8
          }
        },
        {
          "name": "find",
          "docstring": "\n Find the first element in the list that satisfies f.\n\n # Example\n\n ```\n assert_eq!(@list.of([1, 3, 5, 8]).find(fn(element) -> Bool { element % 2 == 0}), Some(8))\n assert_eq!(@list.of([1, 3, 5]).find(fn(element) -> Bool { element % 2 == 0}), None)\n ```",
          "signature": "fn <a href=\"moonbitlang/core/immut/list#T\">T</a>::find[A](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A], f : (A) -> Bool) -> A?",
          "loc": {
            "path": "moonbitlang/core/immut/list",
            "file": "list.mbt",
            "line": 915,
            "column": 8
          }
        },
        {
          "name": "findi",
          "docstring": "\n Find the first element in the list that satisfies f and passes the index as an argument.\n\n # Example\n\n ```\n assert_eq!(@list.of([1, 3, 5, 8]).findi(fn(element, index) -> Bool { (element % 2 == 0) && (index == 3) }), Some(8))\n assert_eq!(@list.of([1, 3, 8, 5]).findi(fn(element, index) -> Bool { (element % 2 == 0) && (index == 3) }), None)\n ```",
          "signature": "fn <a href=\"moonbitlang/core/immut/list#T\">T</a>::findi[A](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A], f : (A, Int) -> Bool) -> A?",
          "loc": {
            "path": "moonbitlang/core/immut/list",
            "file": "list.mbt",
            "line": 936,
            "column": 8
          }
        },
        {
          "name": "flat_map",
          "docstring": "\n map over the list and concat all results.\n\n `flat_map(f, ls)` equal to `ls.map(f).fold(Nil, fn(acc, x) { acc.concat(x) })))`\n\n # Example\n\n ```\n let ls = @list.from_array([1, 2, 3])\n let r = ls.flat_map(fn(x) { @list.from_array([x, x * 2]) })\n assert_eq!(r, @list.from_array([1, 2, 2, 4, 3, 6]))\n ```",
          "signature": "fn <a href=\"moonbitlang/core/immut/list#T\">T</a>::flat_map[A, B](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A], f : (A) -> <a href=\"moonbitlang/core/immut/list#T\">T</a>[B]) -> <a href=\"moonbitlang/core/immut/list#T\">T</a>[B]",
          "loc": {
            "path": "moonbitlang/core/immut/list",
            "file": "list.mbt",
            "line": 514,
            "column": 8
          }
        },
        {
          "name": "flatten",
          "docstring": "\n flatten a list of lists.\n\n # Example\n\n ```\n let ls = @list.flatten(@list.from_array([@list.from_array([1,2,3]), @list.from_array([4,5,6]), @list.from_array([7,8,9])]))\n assert_eq!(ls, @list.from_array([1, 2, 3, 4, 5, 6, 7, 8, 9]))\n ```",
          "signature": "fn <a href=\"moonbitlang/core/immut/list#T\">T</a>::flatten[A](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[<a href=\"moonbitlang/core/immut/list#T\">T</a>[A]]) -> <a href=\"moonbitlang/core/immut/list#T\">T</a>[A]",
          "loc": {
            "path": "moonbitlang/core/immut/list",
            "file": "list.mbt",
            "line": 642,
            "column": 8
          }
        },
        {
          "name": "fold",
          "docstring": "\n Fold the list from left.\n\n # Example\n\n ```\n let r = @list.of([1, 2, 3, 4, 5]).fold(init=0, fn(acc, x) { acc + x })\n assert_eq!(r, 15)\n ```",
          "signature": "fn <a href=\"moonbitlang/core/immut/list#T\">T</a>::fold[A, B](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A], init~ : B, f : (B, A) -> B) -> B",
          "loc": {
            "path": "moonbitlang/core/immut/list",
            "file": "list.mbt",
            "line": 351,
            "column": 8
          }
        },
        {
          "name": "fold_left",
          "docstring": "\n Fold the list from left.\n\n # Example\n\n ```\n let r = @list.of([1, 2, 3, 4, 5]).fold(init=0, fn(acc, x) { acc + x })\n assert_eq!(r, 15)\n ```",
          "signature": "fn <a href=\"moonbitlang/core/immut/list#T\">T</a>::fold_left[A, B](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A], f : (B, A) -> B, init~ : B) -> B",
          "loc": {
            "path": "moonbitlang/core/immut/list",
            "file": "list.mbt",
            "line": 384,
            "column": 8
          }
        },
        {
          "name": "fold_lefti",
          "docstring": "\n Fold the list from left with index.",
          "signature": "fn <a href=\"moonbitlang/core/immut/list#T\">T</a>::fold_lefti[A, B](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A], f : (Int, B, A) -> B, init~ : B) -> B",
          "loc": {
            "path": "moonbitlang/core/immut/list",
            "file": "list.mbt",
            "line": 435,
            "column": 8
          }
        },
        {
          "name": "fold_right",
          "docstring": "\n Fold the list from right.\n\n # Example\n ```\n let r = @list.of([1, 2, 3, 4, 5]).rev_fold(fn(x, acc) { x + acc }, init=0)\n assert_eq!(r, 15)\n ```",
          "signature": "fn <a href=\"moonbitlang/core/immut/list#T\">T</a>::fold_right[A, B](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A], f : (A, B) -> B, init~ : B) -> B",
          "loc": {
            "path": "moonbitlang/core/immut/list",
            "file": "list.mbt",
            "line": 398,
            "column": 8
          }
        },
        {
          "name": "fold_righti",
          "docstring": "\n Fold the list from right with index.",
          "signature": "fn <a href=\"moonbitlang/core/immut/list#T\">T</a>::fold_righti[A, B](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A], f : (Int, A, B) -> B, init~ : B) -> B",
          "loc": {
            "path": "moonbitlang/core/immut/list",
            "file": "list.mbt",
            "line": 450,
            "column": 8
          }
        },
        {
          "name": "foldi",
          "docstring": "\n Fold the list from left with index.",
          "signature": "fn <a href=\"moonbitlang/core/immut/list#T\">T</a>::foldi[A, B](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A], init~ : B, f : (Int, B, A) -> B) -> B",
          "loc": {
            "path": "moonbitlang/core/immut/list",
            "file": "list.mbt",
            "line": 407,
            "column": 8
          }
        },
        {
          "name": "from_array",
          "docstring": "",
          "signature": "fn <a href=\"moonbitlang/core/immut/list#T\">T</a>::from_array[A](arr : <a href=\"moonbitlang/core/array#Array\">Array</a>[A]) -> <a href=\"moonbitlang/core/immut/list#T\">T</a>[A]",
          "loc": {
            "path": "moonbitlang/core/immut/list",
            "file": "deprecated.mbt",
            "line": 66,
            "column": 11
          }
        },
        {
          "name": "from_iter",
          "docstring": "",
          "signature": "fn <a href=\"moonbitlang/core/immut/list#T\">T</a>::from_iter[A](iter : <a href=\"moonbitlang/core/builtin#Iter\">Iter</a>[A]) -> <a href=\"moonbitlang/core/immut/list#T\">T</a>[A]",
          "loc": {
            "path": "moonbitlang/core/immut/list",
            "file": "deprecated.mbt",
            "line": 80,
            "column": 11
          }
        },
        {
          "name": "from_json",
          "docstring": "",
          "signature": "fn <a href=\"moonbitlang/core/immut/list#T\">T</a>::from_json[A : <a href=\"moonbitlang/core/json#FromJson\">@moonbitlang/core/json.FromJson</a>](json : <a href=\"moonbitlang/core/json#Json\">Json</a>) -> <a href=\"moonbitlang/core/immut/list#T\">T</a>[A]!<a href=\"moonbitlang/core/json#JsonDecodeError\">@moonbitlang/core/json.JsonDecodeError</a>",
          "loc": {
            "path": "moonbitlang/core/immut/list",
            "file": "deprecated.mbt",
            "line": 18,
            "column": 11
          }
        },
        {
          "name": "head",
          "docstring": "\n Get first element of the list.\n\n # Example\n\n ```\n assert_eq!(@list.of([1, 2, 3, 4, 5]).head(), Some(1))\n ```",
          "signature": "fn <a href=\"moonbitlang/core/immut/list#T\">T</a>::head[A](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A]) -> A?",
          "loc": {
            "path": "moonbitlang/core/immut/list",
            "file": "list.mbt",
            "line": 265,
            "column": 8
          }
        },
        {
          "name": "head_exn",
          "docstring": "",
          "signature": "fn <a href=\"moonbitlang/core/immut/list#T\">T</a>::head_exn[A](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A]) -> A",
          "loc": {
            "path": "moonbitlang/core/immut/list",
            "file": "list.mbt",
            "line": 253,
            "column": 8
          }
        },
        {
          "name": "init_",
          "docstring": "\n Init of the list.\n\n # Example\n\n ```\n assert_eq!(@list.of([1, 2, 3, 4, 5]).init_(), @list.of([1, 2, 3, 4]))\n ```",
          "signature": "fn <a href=\"moonbitlang/core/immut/list#T\">T</a>::init_[A](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A]) -> <a href=\"moonbitlang/core/immut/list#T\">T</a>[A]",
          "loc": {
            "path": "moonbitlang/core/immut/list",
            "file": "deprecated.mbt",
            "line": 34,
            "column": 8
          }
        },
        {
          "name": "intercalate",
          "docstring": "\n Similar to intersperse but with a list of values.\n\n # Example\n ```\n let ls = @list.of([\n    @list.of([1, 2, 3]),\n    @list.of([4, 5, 6]),\n    @list.of([7, 8, 9]),\n ])\n let r = ls.intercalate(@list.of([0]))\n assert_eq!(r, @list.of([1, 2, 3, 0, 4, 5, 6, 0, 7, 8, 9]))\n ```",
          "signature": "fn <a href=\"moonbitlang/core/immut/list#T\">T</a>::intercalate[A](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[<a href=\"moonbitlang/core/immut/list#T\">T</a>[A]], sep : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A]) -> <a href=\"moonbitlang/core/immut/list#T\">T</a>[A]",
          "loc": {
            "path": "moonbitlang/core/immut/list",
            "file": "list.mbt",
            "line": 1029,
            "column": 8
          }
        },
        {
          "name": "intersperse",
          "docstring": "\n Insert separator to the list.\n\n # Example\n\n ```\n let ls = @list.intersperse(@list.from_array([\"1\", \"2\", \"3\", \"4\", \"5\"]), \"|\")\n assert_eq!(ls, @list.from_array([\"1\", \"|\", \"2\", \"|\", \"3\", \"|\", \"4\", \"|\", \"5\"]))\n ```",
          "signature": "fn <a href=\"moonbitlang/core/immut/list#T\">T</a>::intersperse[A](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A], separator : A) -> <a href=\"moonbitlang/core/immut/list#T\">T</a>[A]",
          "loc": {
            "path": "moonbitlang/core/immut/list",
            "file": "list.mbt",
            "line": 594,
            "column": 8
          }
        },
        {
          "name": "is_empty",
          "docstring": "\n Check if the list is empty.",
          "signature": "fn <a href=\"moonbitlang/core/immut/list#T\">T</a>::is_empty[A](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A]) -> Bool",
          "loc": {
            "path": "moonbitlang/core/immut/list",
            "file": "list.mbt",
            "line": 605,
            "column": 8
          }
        },
        {
          "name": "is_prefix",
          "docstring": "\n Returns true if list starts with prefix.\n\n # Example\n\n ```\n assert_eq!(@list.of([1, 2, 3, 4, 5]).is_prefix(@list.of([1, 2, 3])), true)\n ```",
          "signature": "fn <a href=\"moonbitlang/core/immut/list#T\">T</a>::is_prefix[A : <a href=\"moonbitlang/core/builtin#Eq\">Eq</a>](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A], prefix : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A]) -> Bool",
          "loc": {
            "path": "moonbitlang/core/immut/list",
            "file": "list.mbt",
            "line": 996,
            "column": 8
          }
        },
        {
          "name": "is_suffix",
          "docstring": "\n Returns true if list ends with suffix.\n\n # Example\n\n ```\n assert_eq!(@list.of([1, 2, 3, 4, 5]).is_suffix(@list.of([3, 4, 5])), true)\n ```",
          "signature": "fn <a href=\"moonbitlang/core/immut/list#T\">T</a>::is_suffix[A : <a href=\"moonbitlang/core/builtin#Eq\">Eq</a>](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A], suffix : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A]) -> Bool",
          "loc": {
            "path": "moonbitlang/core/immut/list",
            "file": "list.mbt",
            "line": 1012,
            "column": 8
          }
        },
        {
          "name": "iter",
          "docstring": "",
          "signature": "fn <a href=\"moonbitlang/core/immut/list#T\">T</a>::iter[A](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A]) -> <a href=\"moonbitlang/core/builtin#Iter\">Iter</a>[A]",
          "loc": {
            "path": "moonbitlang/core/immut/list",
            "file": "list.mbt",
            "line": 1045,
            "column": 8
          }
        },
        {
          "name": "iter2",
          "docstring": "",
          "signature": "fn <a href=\"moonbitlang/core/immut/list#T\">T</a>::iter2[A](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A]) -> <a href=\"moonbitlang/core/builtin#Iter2\">Iter2</a>[Int, A]",
          "loc": {
            "path": "moonbitlang/core/immut/list",
            "file": "list.mbt",
            "line": 1060,
            "column": 8
          }
        },
        {
          "name": "last",
          "docstring": "\n Last element of the list.\n\n # Example\n\n ```\n assert_eq!(@list.of([1, 2, 3, 4, 5]).last(), Some(5))\n ```",
          "signature": "fn <a href=\"moonbitlang/core/immut/list#T\">T</a>::last[A](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A]) -> A?",
          "loc": {
            "path": "moonbitlang/core/immut/list",
            "file": "list.mbt",
            "line": 290,
            "column": 8
          }
        },
        {
          "name": "length",
          "docstring": "\n Get the length of the list.",
          "signature": "fn <a href=\"moonbitlang/core/immut/list#T\">T</a>::length[A](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A]) -> Int",
          "loc": {
            "path": "moonbitlang/core/immut/list",
            "file": "list.mbt",
            "line": 77,
            "column": 8
          }
        },
        {
          "name": "lookup",
          "docstring": "\n Looks up a key in an association list.\n\n # Example\n\n ```\n let ls = @list.from_array([(1, \"a\"), (2, \"b\"), (3, \"c\")])\n assert_eq!(ls.lookup(3), Some(\"c\"))\n ```",
          "signature": "fn <a href=\"moonbitlang/core/immut/list#T\">T</a>::lookup[A : <a href=\"moonbitlang/core/builtin#Eq\">Eq</a>, B](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[(A, B)], v : A) -> B?",
          "loc": {
            "path": "moonbitlang/core/immut/list",
            "file": "list.mbt",
            "line": 899,
            "column": 8
          }
        },
        {
          "name": "map",
          "docstring": "\n Maps the list.\n\n # Example\n\n ```\n assert_eq!(@list.of([1, 2, 3, 4, 5]).map(fn(x){ x * 2}), @list.of([2, 4, 6, 8, 10]))\n ```",
          "signature": "fn <a href=\"moonbitlang/core/immut/list#T\">T</a>::map[A, B](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A], f : (A) -> B) -> <a href=\"moonbitlang/core/immut/list#T\">T</a>[B]",
          "loc": {
            "path": "moonbitlang/core/immut/list",
            "file": "list.mbt",
            "line": 132,
            "column": 8
          }
        },
        {
          "name": "mapi",
          "docstring": "\n Maps the list with index.",
          "signature": "fn <a href=\"moonbitlang/core/immut/list#T\">T</a>::mapi[A, B](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A], f : (Int, A) -> B) -> <a href=\"moonbitlang/core/immut/list#T\">T</a>[B]",
          "loc": {
            "path": "moonbitlang/core/immut/list",
            "file": "list.mbt",
            "line": 141,
            "column": 8
          }
        },
        {
          "name": "maximum",
          "docstring": "\n Get maximum element of the list.\n Returns None if the list is empty.",
          "signature": "fn <a href=\"moonbitlang/core/immut/list#T\">T</a>::maximum[A : <a href=\"moonbitlang/core/builtin#Compare\">Compare</a> + <a href=\"moonbitlang/core/builtin#Eq\">Eq</a>](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A]) -> A?",
          "loc": {
            "path": "moonbitlang/core/immut/list",
            "file": "list.mbt",
            "line": 669,
            "column": 8
          }
        },
        {
          "name": "minimum",
          "docstring": "\n Get minimum element of the list.",
          "signature": "fn <a href=\"moonbitlang/core/immut/list#T\">T</a>::minimum[A : <a href=\"moonbitlang/core/builtin#Compare\">Compare</a> + <a href=\"moonbitlang/core/builtin#Eq\">Eq</a>](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A]) -> A?",
          "loc": {
            "path": "moonbitlang/core/immut/list",
            "file": "list.mbt",
            "line": 700,
            "column": 8
          }
        },
        {
          "name": "nth",
          "docstring": "\n Get nth element of the list or None if the index is out of bounds",
          "signature": "fn <a href=\"moonbitlang/core/immut/list#T\">T</a>::nth[A](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A], n : Int) -> A?",
          "loc": {
            "path": "moonbitlang/core/immut/list",
            "file": "list.mbt",
            "line": 561,
            "column": 8
          }
        },
        {
          "name": "nth_exn",
          "docstring": "",
          "signature": "fn <a href=\"moonbitlang/core/immut/list#T\">T</a>::nth_exn[A](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A], n : Int) -> A",
          "loc": {
            "path": "moonbitlang/core/immut/list",
            "file": "list.mbt",
            "line": 555,
            "column": 8
          }
        },
        {
          "name": "of",
          "docstring": "",
          "signature": "fn <a href=\"moonbitlang/core/immut/list#T\">T</a>::of[A](arr : <a href=\"moonbitlang/core/array#FixedArray\">FixedArray</a>[A]) -> <a href=\"moonbitlang/core/immut/list#T\">T</a>[A]",
          "loc": {
            "path": "moonbitlang/core/immut/list",
            "file": "deprecated.mbt",
            "line": 87,
            "column": 11
          }
        },
        {
          "name": "remove",
          "docstring": "\n Removes the first occurrence of the specified element from the list, if it is present.\n\n # Example\n\n ```\n assert_eq!(@list.of([1, 2, 3, 4, 5]).remove(3), @list.of([1, 2, 4, 5]))\n ```",
          "signature": "fn <a href=\"moonbitlang/core/immut/list#T\">T</a>::remove[A : <a href=\"moonbitlang/core/builtin#Eq\">Eq</a>](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A], elem : A) -> <a href=\"moonbitlang/core/immut/list#T\">T</a>[A]",
          "loc": {
            "path": "moonbitlang/core/immut/list",
            "file": "list.mbt",
            "line": 976,
            "column": 8
          }
        },
        {
          "name": "remove_at",
          "docstring": "\n Removes the element at the specified index in the list.\n\n # Example\n\n ```\n assert_eq!(@list.of([1, 2, 3, 4, 5]).remove_at(2), @list.of([1, 2, 4, 5]))\n ```",
          "signature": "fn <a href=\"moonbitlang/core/immut/list#T\">T</a>::remove_at[A](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A], index : Int) -> <a href=\"moonbitlang/core/immut/list#T\">T</a>[A]",
          "loc": {
            "path": "moonbitlang/core/immut/list",
            "file": "list.mbt",
            "line": 959,
            "column": 8
          }
        },
        {
          "name": "rev",
          "docstring": "\n Reverse the list.\n\n # Example\n\n ```\n assert_eq!(@list.of([1, 2, 3, 4, 5]).rev(), @list.of([5, 4, 3, 2, 1]))\n ```",
          "signature": "fn <a href=\"moonbitlang/core/immut/list#T\">T</a>::rev[A](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A]) -> <a href=\"moonbitlang/core/immut/list#T\">T</a>[A]",
          "loc": {
            "path": "moonbitlang/core/immut/list",
            "file": "list.mbt",
            "line": 338,
            "column": 8
          }
        },
        {
          "name": "rev_concat",
          "docstring": "\n Reverse the first list and concatenate it with the second.\n\n # Example\n\n ```\n let ls = @list.of([1, 2, 3, 4, 5]).rev_concat(@list.of([6, 7, 8, 9, 10]))\n assert_eq!(ls, @list.of([5, 4, 3, 2, 1, 6, 7, 8, 9, 10]))\n ```",
          "signature": "fn <a href=\"moonbitlang/core/immut/list#T\">T</a>::rev_concat[A](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A], other : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A]) -> <a href=\"moonbitlang/core/immut/list#T\">T</a>[A]",
          "loc": {
            "path": "moonbitlang/core/immut/list",
            "file": "list.mbt",
            "line": 323,
            "column": 8
          }
        },
        {
          "name": "rev_fold",
          "docstring": "\n Fold the list from right.\n\n # Example\n ```\n let r = @list.of([1, 2, 3, 4, 5]).rev_fold(fn(x, acc) { x + acc }, init=0)\n assert_eq!(r, 15)\n ```",
          "signature": "fn <a href=\"moonbitlang/core/immut/list#T\">T</a>::rev_fold[A, B](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A], init~ : B, f : (A, B) -> B) -> B",
          "loc": {
            "path": "moonbitlang/core/immut/list",
            "file": "list.mbt",
            "line": 366,
            "column": 8
          }
        },
        {
          "name": "rev_foldi",
          "docstring": "\n Fold the list from right with index.",
          "signature": "fn <a href=\"moonbitlang/core/immut/list#T\">T</a>::rev_foldi[A, B](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A], init~ : B, f : (Int, A, B) -> B) -> B",
          "loc": {
            "path": "moonbitlang/core/immut/list",
            "file": "list.mbt",
            "line": 420,
            "column": 8
          }
        },
        {
          "name": "rev_map",
          "docstring": "\n Maps the list and reverses the result.\n\n `list.rev_map(f)` is equivalent to `list.map(f).rev()` but more efficient.\n\n # Example\n ```\n assert_eq!(@list.of([1, 2, 3, 4, 5]).rev_map(fn(x) { x * 2 }), @list.of([10, 8, 6, 4, 2]))\n ```",
          "signature": "fn <a href=\"moonbitlang/core/immut/list#T\">T</a>::rev_map[A, B](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A], f : (A) -> B) -> <a href=\"moonbitlang/core/immut/list#T\">T</a>[B]",
          "loc": {
            "path": "moonbitlang/core/immut/list",
            "file": "list.mbt",
            "line": 161,
            "column": 8
          }
        },
        {
          "name": "scan_left",
          "docstring": "\n Fold a list and return a list of successive reduced values from the left\n\n # Example\n\n ```\n let ls = @list.of([1, 2, 3, 4, 5])\n let r = ls.scan_left(fn(acc, x) { acc + x }, init=0)\n assert_eq!(r, @list.of([0, 1, 3, 6, 10, 15]))\n ```",
          "signature": "fn <a href=\"moonbitlang/core/immut/list#T\">T</a>::scan_left[A, E](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A], f : (E, A) -> E, init~ : E) -> <a href=\"moonbitlang/core/immut/list#T\">T</a>[E]",
          "loc": {
            "path": "moonbitlang/core/immut/list",
            "file": "list.mbt",
            "line": 859,
            "column": 8
          }
        },
        {
          "name": "scan_right",
          "docstring": "\n Fold a list and return a list of successive reduced values from the right\n\n Note that the order of parameters on the accumulating function are reversed.\n\n # Example\n ```\n let ls = @list.of([1, 2, 3, 4, 5])\n let r = ls.scan_right(fn(x, acc) { acc + x }, init=0)\n assert_eq!(r, @list.of([15, 14, 12, 9, 5, 0]))\n ```",
          "signature": "fn <a href=\"moonbitlang/core/immut/list#T\">T</a>::scan_right[A, B](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A], f : (A, B) -> B, init~ : B) -> <a href=\"moonbitlang/core/immut/list#T\">T</a>[B]",
          "loc": {
            "path": "moonbitlang/core/immut/list",
            "file": "list.mbt",
            "line": 880,
            "column": 8
          }
        },
        {
          "name": "sort",
          "docstring": "\n Sort the list in ascending order.\n\n # Example\n\n ```\n let ls = @list.sort(@list.from_array([1,123,52,3,6,0,-6,-76]))\n assert_eq!(ls, @list.from_array([-76, -6, 0, 1, 3, 6, 52, 123]))\n ```",
          "signature": "fn <a href=\"moonbitlang/core/immut/list#T\">T</a>::sort[A : <a href=\"moonbitlang/core/builtin#Compare\">Compare</a> + <a href=\"moonbitlang/core/builtin#Eq\">Eq</a>](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A]) -> <a href=\"moonbitlang/core/immut/list#T\">T</a>[A]",
          "loc": {
            "path": "moonbitlang/core/immut/list",
            "file": "list.mbt",
            "line": 721,
            "column": 8
          }
        },
        {
          "name": "tail",
          "docstring": "\n Tail of the list.\n\n # Example\n\n ```\n assert_eq!(@list.of([1, 2, 3, 4, 5]).tail(), @list.of([2, 3, 4, 5]))\n ```",
          "signature": "fn <a href=\"moonbitlang/core/immut/list#T\">T</a>::tail[A](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A]) -> <a href=\"moonbitlang/core/immut/list#T\">T</a>[A]",
          "loc": {
            "path": "moonbitlang/core/immut/list",
            "file": "list.mbt",
            "line": 233,
            "column": 8
          }
        },
        {
          "name": "take",
          "docstring": "\n Take first n elements of the list.\n If the list is shorter than n, return the whole list.\n\n # Example\n\n ```\n let ls = @list.of([1, 2, 3, 4, 5])\n let r = ls.take(3)\n assert_eq!(r, @list.of([1, 2, 3]))\n ```",
          "signature": "fn <a href=\"moonbitlang/core/immut/list#T\">T</a>::take[A](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A], n : Int) -> <a href=\"moonbitlang/core/immut/list#T\">T</a>[A]",
          "loc": {
            "path": "moonbitlang/core/immut/list",
            "file": "list.mbt",
            "line": 776,
            "column": 8
          }
        },
        {
          "name": "take_while",
          "docstring": "\n Take the longest prefix of a list of elements that satisfies a given predicate.\n\n # Example\n\n ```\n let ls = @list.from_array([1, 2, 3, 4])\n let r = ls.take_while(fn(x) { x < 3 })\n assert_eq!(r, @list.of([1, 2]))\n ```",
          "signature": "fn <a href=\"moonbitlang/core/immut/list#T\">T</a>::take_while[A](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A], p : (A) -> Bool) -> <a href=\"moonbitlang/core/immut/list#T\">T</a>[A]",
          "loc": {
            "path": "moonbitlang/core/immut/list",
            "file": "list.mbt",
            "line": 825,
            "column": 8
          }
        },
        {
          "name": "to_array",
          "docstring": "\n Convert list to array.",
          "signature": "fn <a href=\"moonbitlang/core/immut/list#T\">T</a>::to_array[A](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A]) -> <a href=\"moonbitlang/core/array#Array\">Array</a>[A]",
          "loc": {
            "path": "moonbitlang/core/immut/list",
            "file": "list.mbt",
            "line": 170,
            "column": 8
          }
        },
        {
          "name": "to_json",
          "docstring": "",
          "signature": "fn <a href=\"moonbitlang/core/immut/list#T\">T</a>::to_json[A : <a href=\"moonbitlang/core/builtin#ToJson\">ToJson</a>](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A]) -> <a href=\"moonbitlang/core/json#Json\">Json</a>",
          "loc": {
            "path": "moonbitlang/core/immut/list",
            "file": "list.mbt",
            "line": 37,
            "column": 8
          }
        },
        {
          "name": "unsafe_head",
          "docstring": "\n Get first element of the list.\n @alert unsafe \"Panic if the list is empty\"",
          "signature": "fn <a href=\"moonbitlang/core/immut/list#T\">T</a>::unsafe_head[A](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A]) -> A",
          "loc": {
            "path": "moonbitlang/core/immut/list",
            "file": "list.mbt",
            "line": 243,
            "column": 8
          }
        },
        {
          "name": "unsafe_last",
          "docstring": "\n @alert unsafe \"Panic if the list is empty\"",
          "signature": "fn <a href=\"moonbitlang/core/immut/list#T\">T</a>::unsafe_last[A](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A]) -> A",
          "loc": {
            "path": "moonbitlang/core/immut/list",
            "file": "list.mbt",
            "line": 274,
            "column": 8
          }
        },
        {
          "name": "unsafe_maximum",
          "docstring": "\n @alert unsafe \"Panic if the list is empty\"",
          "signature": "fn <a href=\"moonbitlang/core/immut/list#T\">T</a>::unsafe_maximum[A : <a href=\"moonbitlang/core/builtin#Compare\">Compare</a> + <a href=\"moonbitlang/core/builtin#Eq\">Eq</a>](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A]) -> A",
          "loc": {
            "path": "moonbitlang/core/immut/list",
            "file": "list.mbt",
            "line": 651,
            "column": 8
          }
        },
        {
          "name": "unsafe_minimum",
          "docstring": "\n @alert unsafe \"Panic if the list is empty\"",
          "signature": "fn <a href=\"moonbitlang/core/immut/list#T\">T</a>::unsafe_minimum[A : <a href=\"moonbitlang/core/builtin#Compare\">Compare</a> + <a href=\"moonbitlang/core/builtin#Eq\">Eq</a>](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A]) -> A",
          "loc": {
            "path": "moonbitlang/core/immut/list",
            "file": "list.mbt",
            "line": 683,
            "column": 8
          }
        },
        {
          "name": "unsafe_nth",
          "docstring": "\n @alert unsafe \"Panic if the index is out of bounds\"",
          "signature": "fn <a href=\"moonbitlang/core/immut/list#T\">T</a>::unsafe_nth[A](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A], n : Int) -> A",
          "loc": {
            "path": "moonbitlang/core/immut/list",
            "file": "list.mbt",
            "line": 544,
            "column": 8
          }
        },
        {
          "name": "unzip",
          "docstring": "\n Unzip two lists.\n\n # Example\n\n ```\n let (a,b) = @list.unzip(@list.from_array([(1,2),(3,4),(5,6)]))\n assert_eq!(a, @list.from_array([1, 3, 5]))\n assert_eq!(b, @list.from_array([2, 4, 6]))\n ```",
          "signature": "fn <a href=\"moonbitlang/core/immut/list#T\">T</a>::unzip[A, B](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[(A, B)]) -> (<a href=\"moonbitlang/core/immut/list#T\">T</a>[A], <a href=\"moonbitlang/core/immut/list#T\">T</a>[B])",
          "loc": {
            "path": "moonbitlang/core/immut/list",
            "file": "list.mbt",
            "line": 619,
            "column": 8
          }
        },
        {
          "name": "zip",
          "docstring": "\n Zip two lists.\n If the lists have different lengths, it will return None.\n\n # Example\n\n ```\n let r = @list.zip(@list.of([1, 2, 3, 4, 5]), @list.of([6, 7, 8, 9, 10]))\n assert_eq!(r, Some(@list.from_array([(1, 6), (2, 7), (3, 8), (4, 9), (5, 10)])))\n ```",
          "signature": "fn <a href=\"moonbitlang/core/immut/list#T\">T</a>::zip[A, B](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A], other : <a href=\"moonbitlang/core/immut/list#T\">T</a>[B]) -> <a href=\"moonbitlang/core/immut/list#T\">T</a>[(A, B)]?",
          "loc": {
            "path": "moonbitlang/core/immut/list",
            "file": "list.mbt",
            "line": 471,
            "column": 8
          }
        }
      ],
      "impls": [
        {
          "self": {
            "kind": "constr",
            "constructor": {
              "name": "T",
              "path": "moonbitlang/core/immut/list"
            },
            "arguments": [ { "kind": "param", "name": "A" } ]
          },
          "trait": { "name": "Add", "path": "moonbitlang/core/builtin" },
          "methods": [
            {
              "name": "op_add",
              "docstring": "\n Concatenate two lists.\n\n `a + b` equal to `a.concat(b)`",
              "signature": "fn op_add[A](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A], other : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A]) -> <a href=\"moonbitlang/core/immut/list#T\">T</a>[A]",
              "loc": {
                "path": "moonbitlang/core/immut/list",
                "file": "list.mbt",
                "line": 736,
                "column": 31
              }
            }
          ]
        },
        {
          "self": {
            "kind": "constr",
            "constructor": {
              "name": "T",
              "path": "moonbitlang/core/immut/list"
            },
            "arguments": [ { "kind": "param", "name": "X" } ]
          },
          "trait": { "name": "Default", "path": "moonbitlang/core/builtin" },
          "methods": [
            {
              "name": "default",
              "docstring": "",
              "signature": "fn default[X]() -> <a href=\"moonbitlang/core/immut/list#T\">T</a>[X]",
              "loc": {
                "path": "moonbitlang/core/immut/list",
                "file": "list.mbt",
                "line": 1034,
                "column": 35
              }
            }
          ]
        },
        {
          "self": {
            "kind": "constr",
            "constructor": {
              "name": "T",
              "path": "moonbitlang/core/immut/list"
            },
            "arguments": [ { "kind": "param", "name": "A" } ]
          },
          "trait": { "name": "Eq", "path": "moonbitlang/core/builtin" },
          "methods": [
            {
              "name": "op_equal",
              "docstring": "automatically derived",
              "signature": "fn op_equal[A : <a href=\"moonbitlang/core/builtin#Eq\">Eq</a>](<a href=\"moonbitlang/core/immut/list#T\">T</a>[A], <a href=\"moonbitlang/core/immut/list#T\">T</a>[A]) -> Bool",
              "loc": {
                "path": "moonbitlang/core/immut/list",
                "file": "types.mbt",
                "line": 19,
                "column": 10
              }
            }
          ]
        },
        {
          "self": {
            "kind": "constr",
            "constructor": {
              "name": "T",
              "path": "moonbitlang/core/immut/list"
            },
            "arguments": [ { "kind": "param", "name": "A" } ]
          },
          "trait": { "name": "Hash", "path": "moonbitlang/core/builtin" },
          "methods": [
            {
              "name": "hash_combine",
              "docstring": "",
              "signature": "fn hash_combine[A : <a href=\"moonbitlang/core/builtin#Hash\">Hash</a>](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A], hasher : <a href=\"moonbitlang/core/builtin#Hasher\">Hasher</a>) -> Unit",
              "loc": {
                "path": "moonbitlang/core/immut/list",
                "file": "list.mbt",
                "line": 1110,
                "column": 39
              }
            }
          ]
        },
        {
          "self": {
            "kind": "constr",
            "constructor": {
              "name": "T",
              "path": "moonbitlang/core/immut/list"
            },
            "arguments": [ { "kind": "param", "name": "A" } ]
          },
          "trait": { "name": "Show", "path": "moonbitlang/core/builtin" },
          "methods": [
            {
              "name": "output",
              "docstring": "",
              "signature": "fn output[A : <a href=\"moonbitlang/core/builtin#Show\">Show</a>](xs : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A], logger : <a href=\"moonbitlang/core/builtin#Logger\">Logger</a>) -> Unit",
              "loc": {
                "path": "moonbitlang/core/immut/list",
                "file": "list.mbt",
                "line": 21,
                "column": 39
              }
            }
          ]
        },
        {
          "self": {
            "kind": "constr",
            "constructor": {
              "name": "T",
              "path": "moonbitlang/core/immut/list"
            },
            "arguments": [ { "kind": "param", "name": "A" } ]
          },
          "trait": { "name": "ToJson", "path": "moonbitlang/core/builtin" },
          "methods": [
            {
              "name": "to_json",
              "docstring": "",
              "signature": "fn to_json[A : <a href=\"moonbitlang/core/builtin#ToJson\">ToJson</a>](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A]) -> <a href=\"moonbitlang/core/json#Json\">Json</a>",
              "loc": {
                "path": "moonbitlang/core/immut/list",
                "file": "list.mbt",
                "line": 26,
                "column": 43
              }
            }
          ]
        },
        {
          "self": {
            "kind": "constr",
            "constructor": {
              "name": "T",
              "path": "moonbitlang/core/immut/list"
            },
            "arguments": [ { "kind": "param", "name": "A" } ]
          },
          "trait": { "name": "FromJson", "path": "moonbitlang/core/json" },
          "methods": [
            {
              "name": "from_json",
              "docstring": "",
              "signature": "fn from_json[A : <a href=\"moonbitlang/core/json#FromJson\">@moonbitlang/core/json.FromJson</a>](json : <a href=\"moonbitlang/core/json#Json\">Json</a>, path : <a href=\"moonbitlang/core/json#JsonPath\">@moonbitlang/core/json.JsonPath</a>) -> <a href=\"moonbitlang/core/immut/list#T\">T</a>[A]!<a href=\"moonbitlang/core/json#JsonDecodeError\">@moonbitlang/core/json.JsonDecodeError</a>",
              "loc": {
                "path": "moonbitlang/core/immut/list",
                "file": "list.mbt",
                "line": 42,
                "column": 59
              }
            }
          ]
        },
        {
          "self": {
            "kind": "constr",
            "constructor": {
              "name": "T",
              "path": "moonbitlang/core/immut/list"
            },
            "arguments": [ { "kind": "param", "name": "X" } ]
          },
          "trait": {
            "name": "Arbitrary",
            "path": "moonbitlang/core/quickcheck"
          },
          "methods": [
            {
              "name": "arbitrary",
              "docstring": "",
              "signature": "fn arbitrary[X : <a href=\"moonbitlang/core/quickcheck#Arbitrary\">@moonbitlang/core/quickcheck.Arbitrary</a>](size : Int, rs : <a href=\"moonbitlang/core/quickcheck/splitmix#RandomState\">@moonbitlang/core/quickcheck/splitmix.RandomState</a>) -> <a href=\"moonbitlang/core/immut/list#T\">T</a>[X]",
              "loc": {
                "path": "moonbitlang/core/immut/list",
                "file": "list.mbt",
                "line": 1097,
                "column": 73
              }
            }
          ]
        }
      ]
    }
  ],
  "typealias": [],
  "values": [
    {
      "name": "add",
      "docstring": "",
      "signature": "fn add[A](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A], head : A) -> <a href=\"moonbitlang/core/immut/list#T\">T</a>[A]",
      "loc": {
        "path": "moonbitlang/core/immut/list",
        "file": "list.mbt",
        "line": 16,
        "column": 8
      }
    },
    {
      "name": "all",
      "docstring": "\n Test if all elements of the list satisfy the predicate.",
      "signature": "fn all[A](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A], f : (A) -> Bool) -> Bool",
      "loc": {
        "path": "moonbitlang/core/immut/list",
        "file": "list.mbt",
        "line": 209,
        "column": 8
      }
    },
    {
      "name": "any",
      "docstring": "\n Test if any element of the list satisfies the predicate.",
      "signature": "fn any[A](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A], f : (A) -> Bool) -> Bool",
      "loc": {
        "path": "moonbitlang/core/immut/list",
        "file": "list.mbt",
        "line": 218,
        "column": 8
      }
    },
    {
      "name": "concat",
      "docstring": "\n Concatenate two lists.\n\n # Example\n\n ```\n let ls = @list.of([1, 2, 3, 4, 5]).concat(@list.of([6, 7, 8, 9, 10]))\n assert_eq!(ls, @list.of([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]))\n ```",
      "signature": "fn concat[A](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A], other : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A]) -> <a href=\"moonbitlang/core/immut/list#T\">T</a>[A]",
      "loc": {
        "path": "moonbitlang/core/immut/list",
        "file": "list.mbt",
        "line": 307,
        "column": 8
      }
    },
    {
      "name": "concat_map",
      "docstring": "\n map over the list and concat all results.\n\n `concat_map(f, ls)` equal to `ls.map(f).fold(Nil, fn(acc, x) { acc.concat(x) })))`\n\n # Example\n\n ```\n let ls = @list.from_array([1, 2, 3])\n let r = ls.flat_map(fn(x) { @list.from_array([x, x * 2]) })\n assert_eq!(r, @list.from_array([1, 2, 2, 4, 3, 6]))\n ```",
      "signature": "fn concat_map[A, B](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A], f : (A) -> <a href=\"moonbitlang/core/immut/list#T\">T</a>[B]) -> <a href=\"moonbitlang/core/immut/list#T\">T</a>[B]",
      "loc": {
        "path": "moonbitlang/core/immut/list",
        "file": "list.mbt",
        "line": 498,
        "column": 8
      }
    },
    {
      "name": "contains",
      "docstring": "\n Check if the list contains the value.",
      "signature": "fn contains[A : <a href=\"moonbitlang/core/builtin#Eq\">Eq</a>](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A], value : A) -> Bool",
      "loc": {
        "path": "moonbitlang/core/immut/list",
        "file": "list.mbt",
        "line": 742,
        "column": 8
      }
    },
    {
      "name": "default",
      "docstring": "\n The empty list",
      "signature": "fn default[X]() -> <a href=\"moonbitlang/core/immut/list#T\">T</a>[X]",
      "loc": {
        "path": "moonbitlang/core/immut/list",
        "file": "list.mbt",
        "line": 1040,
        "column": 8
      }
    },
    {
      "name": "drop",
      "docstring": "\n Drop first n elements of the list.\n If the list is shorter than n, return an empty list.\n\n # Example\n\n ```\n let ls = @list.of([1, 2, 3, 4, 5])\n let r = ls.drop(3)\n assert_eq!(r, @list.of([4, 5]))\n ```",
      "signature": "fn drop[A](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A], n : Int) -> <a href=\"moonbitlang/core/immut/list#T\">T</a>[A]",
      "loc": {
        "path": "moonbitlang/core/immut/list",
        "file": "list.mbt",
        "line": 801,
        "column": 8
      }
    },
    {
      "name": "drop_while",
      "docstring": "\n Drop the longest prefix of a list of elements that satisfies a given predicate.\n\n # Example\n\n ```\n let ls = @list.from_array([1, 2, 3, 4])\n let r = ls.drop_while(fn(x) { x < 3 })\n assert_eq!(r, @list.of([3, 4]))\n ```",
      "signature": "fn drop_while[A](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A], p : (A) -> Bool) -> <a href=\"moonbitlang/core/immut/list#T\">T</a>[A]",
      "loc": {
        "path": "moonbitlang/core/immut/list",
        "file": "list.mbt",
        "line": 842,
        "column": 8
      }
    },
    {
      "name": "each",
      "docstring": "\n Iterates over the list.\n\n # Example\n\n ```\n let arr = []\n @list.of([1, 2, 3, 4, 5]).each(fn(x) { arr.push(x) })\n assert_eq!(arr, [1, 2, 3, 4, 5])\n ```",
      "signature": "fn each[A](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A], f : (A) -> Unit) -> Unit",
      "loc": {
        "path": "moonbitlang/core/immut/list",
        "file": "list.mbt",
        "line": 94,
        "column": 8
      }
    },
    {
      "name": "eachi",
      "docstring": "\n Iterates over the list with index.\n\n # Example\n\n ```\n let arr = []\n @list.of([1, 2, 3, 4, 5]).eachi(fn(i, x) { arr.push(\"(\\{i},\\{x})\") })\n assert_eq!(arr, [\"(0,1)\", \"(1,2)\", \"(2,3)\", \"(3,4)\", \"(4,5)\"])\n ```",
      "signature": "fn eachi[A](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A], f : (Int, A) -> Unit) -> Unit",
      "loc": {
        "path": "moonbitlang/core/immut/list",
        "file": "list.mbt",
        "line": 114,
        "column": 8
      }
    },
    {
      "name": "equal",
      "docstring": "\n Compares two lists for equality.\n\n # Example\n\n ```\n assert_eq!(@list.of([1, 2, 3]) == @list.of([1, 2, 3]), true)\n ```",
      "signature": "fn equal[A : <a href=\"moonbitlang/core/builtin#Eq\">Eq</a>](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A], other : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A]) -> Bool",
      "loc": {
        "path": "moonbitlang/core/immut/list",
        "file": "deprecated.mbt",
        "line": 55,
        "column": 8
      }
    },
    {
      "name": "filter",
      "docstring": "\n Filter the list.\n\n # Example\n\n ```\n assert_eq!(@list.of([1, 2, 3, 4, 5]).filter(fn(x){ x % 2 == 0}), @list.of([2, 4]))\n ```",
      "signature": "fn filter[A](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A], f : (A) -> Bool) -> <a href=\"moonbitlang/core/immut/list#T\">T</a>[A]",
      "loc": {
        "path": "moonbitlang/core/immut/list",
        "file": "list.mbt",
        "line": 195,
        "column": 8
      }
    },
    {
      "name": "filter_map",
      "docstring": "\n Map over the list and keep all `value`s for which the mapped result is `Some(value)`.\n\n # Example\n\n ```\n let ls = @list.of([4, 2, 2, 6, 3, 1])\n let r = ls.filter_map(fn(x) { if (x >= 3) { Some(x) } else { None } })\n assert_eq!(r, @list.of([4, 6, 3]))\n ```",
      "signature": "fn filter_map[A, B](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A], f : (A) -> B?) -> <a href=\"moonbitlang/core/immut/list#T\">T</a>[B]",
      "loc": {
        "path": "moonbitlang/core/immut/list",
        "file": "list.mbt",
        "line": 531,
        "column": 8
      }
    },
    {
      "name": "find",
      "docstring": "\n Find the first element in the list that satisfies f.\n\n # Example\n\n ```\n assert_eq!(@list.of([1, 3, 5, 8]).find(fn(element) -> Bool { element % 2 == 0}), Some(8))\n assert_eq!(@list.of([1, 3, 5]).find(fn(element) -> Bool { element % 2 == 0}), None)\n ```",
      "signature": "fn find[A](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A], f : (A) -> Bool) -> A?",
      "loc": {
        "path": "moonbitlang/core/immut/list",
        "file": "list.mbt",
        "line": 915,
        "column": 8
      }
    },
    {
      "name": "findi",
      "docstring": "\n Find the first element in the list that satisfies f and passes the index as an argument.\n\n # Example\n\n ```\n assert_eq!(@list.of([1, 3, 5, 8]).findi(fn(element, index) -> Bool { (element % 2 == 0) && (index == 3) }), Some(8))\n assert_eq!(@list.of([1, 3, 8, 5]).findi(fn(element, index) -> Bool { (element % 2 == 0) && (index == 3) }), None)\n ```",
      "signature": "fn findi[A](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A], f : (A, Int) -> Bool) -> A?",
      "loc": {
        "path": "moonbitlang/core/immut/list",
        "file": "list.mbt",
        "line": 936,
        "column": 8
      }
    },
    {
      "name": "flat_map",
      "docstring": "\n map over the list and concat all results.\n\n `flat_map(f, ls)` equal to `ls.map(f).fold(Nil, fn(acc, x) { acc.concat(x) })))`\n\n # Example\n\n ```\n let ls = @list.from_array([1, 2, 3])\n let r = ls.flat_map(fn(x) { @list.from_array([x, x * 2]) })\n assert_eq!(r, @list.from_array([1, 2, 2, 4, 3, 6]))\n ```",
      "signature": "fn flat_map[A, B](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A], f : (A) -> <a href=\"moonbitlang/core/immut/list#T\">T</a>[B]) -> <a href=\"moonbitlang/core/immut/list#T\">T</a>[B]",
      "loc": {
        "path": "moonbitlang/core/immut/list",
        "file": "list.mbt",
        "line": 514,
        "column": 8
      }
    },
    {
      "name": "flatten",
      "docstring": "\n flatten a list of lists.\n\n # Example\n\n ```\n let ls = @list.flatten(@list.from_array([@list.from_array([1,2,3]), @list.from_array([4,5,6]), @list.from_array([7,8,9])]))\n assert_eq!(ls, @list.from_array([1, 2, 3, 4, 5, 6, 7, 8, 9]))\n ```",
      "signature": "fn flatten[A](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[<a href=\"moonbitlang/core/immut/list#T\">T</a>[A]]) -> <a href=\"moonbitlang/core/immut/list#T\">T</a>[A]",
      "loc": {
        "path": "moonbitlang/core/immut/list",
        "file": "list.mbt",
        "line": 642,
        "column": 8
      }
    },
    {
      "name": "fold",
      "docstring": "\n Fold the list from left.\n\n # Example\n\n ```\n let r = @list.of([1, 2, 3, 4, 5]).fold(init=0, fn(acc, x) { acc + x })\n assert_eq!(r, 15)\n ```",
      "signature": "fn fold[A, B](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A], init~ : B, f : (B, A) -> B) -> B",
      "loc": {
        "path": "moonbitlang/core/immut/list",
        "file": "list.mbt",
        "line": 351,
        "column": 8
      }
    },
    {
      "name": "fold_left",
      "docstring": "\n Fold the list from left.\n\n # Example\n\n ```\n let r = @list.of([1, 2, 3, 4, 5]).fold(init=0, fn(acc, x) { acc + x })\n assert_eq!(r, 15)\n ```",
      "signature": "fn fold_left[A, B](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A], f : (B, A) -> B, init~ : B) -> B",
      "loc": {
        "path": "moonbitlang/core/immut/list",
        "file": "list.mbt",
        "line": 384,
        "column": 8
      }
    },
    {
      "name": "fold_lefti",
      "docstring": "\n Fold the list from left with index.",
      "signature": "fn fold_lefti[A, B](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A], f : (Int, B, A) -> B, init~ : B) -> B",
      "loc": {
        "path": "moonbitlang/core/immut/list",
        "file": "list.mbt",
        "line": 435,
        "column": 8
      }
    },
    {
      "name": "fold_right",
      "docstring": "\n Fold the list from right.\n\n # Example\n ```\n let r = @list.of([1, 2, 3, 4, 5]).rev_fold(fn(x, acc) { x + acc }, init=0)\n assert_eq!(r, 15)\n ```",
      "signature": "fn fold_right[A, B](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A], f : (A, B) -> B, init~ : B) -> B",
      "loc": {
        "path": "moonbitlang/core/immut/list",
        "file": "list.mbt",
        "line": 398,
        "column": 8
      }
    },
    {
      "name": "fold_righti",
      "docstring": "\n Fold the list from right with index.",
      "signature": "fn fold_righti[A, B](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A], f : (Int, A, B) -> B, init~ : B) -> B",
      "loc": {
        "path": "moonbitlang/core/immut/list",
        "file": "list.mbt",
        "line": 450,
        "column": 8
      }
    },
    {
      "name": "foldi",
      "docstring": "\n Fold the list from left with index.",
      "signature": "fn foldi[A, B](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A], init~ : B, f : (Int, B, A) -> B) -> B",
      "loc": {
        "path": "moonbitlang/core/immut/list",
        "file": "list.mbt",
        "line": 407,
        "column": 8
      }
    },
    {
      "name": "from_array",
      "docstring": "\n Convert array to list.\n\n # Example\n\n ```\n let ls = @list.of([1, 2, 3, 4, 5])\n assert_eq!(ls, @list.from_array([1, 2, 3, 4, 5]))\n ```",
      "signature": "fn from_array[A](arr : <a href=\"moonbitlang/core/array#Array\">Array</a>[A]) -> <a href=\"moonbitlang/core/immut/list#T\">T</a>[A]",
      "loc": {
        "path": "moonbitlang/core/immut/list",
        "file": "list.mbt",
        "line": 67,
        "column": 8
      }
    },
    {
      "name": "from_iter",
      "docstring": "\n Convert the iterator into a list. Preserves order of elements.\n This function is tail-recursive, but consumes 2*n memory. \n If the order of elements is not important, use `from_iter_rev` instead.",
      "signature": "fn from_iter[A](iter : <a href=\"moonbitlang/core/builtin#Iter\">Iter</a>[A]) -> <a href=\"moonbitlang/core/immut/list#T\">T</a>[A]",
      "loc": {
        "path": "moonbitlang/core/immut/list",
        "file": "list.mbt",
        "line": 1078,
        "column": 8
      }
    },
    {
      "name": "from_iter_rev",
      "docstring": "",
      "signature": "fn from_iter_rev[A](iter : <a href=\"moonbitlang/core/builtin#Iter\">Iter</a>[A]) -> <a href=\"moonbitlang/core/immut/list#T\">T</a>[A]",
      "loc": {
        "path": "moonbitlang/core/immut/list",
        "file": "list.mbt",
        "line": 1083,
        "column": 8
      }
    },
    {
      "name": "from_json",
      "docstring": "",
      "signature": "fn from_json[A : <a href=\"moonbitlang/core/json#FromJson\">@moonbitlang/core/json.FromJson</a>](json : <a href=\"moonbitlang/core/json#Json\">Json</a>) -> <a href=\"moonbitlang/core/immut/list#T\">T</a>[A]!<a href=\"moonbitlang/core/json#JsonDecodeError\">@moonbitlang/core/json.JsonDecodeError</a>",
      "loc": {
        "path": "moonbitlang/core/immut/list",
        "file": "list.mbt",
        "line": 54,
        "column": 8
      }
    },
    {
      "name": "head",
      "docstring": "\n Get first element of the list.\n\n # Example\n\n ```\n assert_eq!(@list.of([1, 2, 3, 4, 5]).head(), Some(1))\n ```",
      "signature": "fn head[A](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A]) -> A?",
      "loc": {
        "path": "moonbitlang/core/immut/list",
        "file": "list.mbt",
        "line": 265,
        "column": 8
      }
    },
    {
      "name": "head_exn",
      "docstring": "",
      "signature": "fn head_exn[A](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A]) -> A",
      "loc": {
        "path": "moonbitlang/core/immut/list",
        "file": "list.mbt",
        "line": 253,
        "column": 8
      }
    },
    {
      "name": "init_",
      "docstring": "\n Init of the list.\n\n # Example\n\n ```\n assert_eq!(@list.of([1, 2, 3, 4, 5]).init_(), @list.of([1, 2, 3, 4]))\n ```",
      "signature": "fn init_[A](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A]) -> <a href=\"moonbitlang/core/immut/list#T\">T</a>[A]",
      "loc": {
        "path": "moonbitlang/core/immut/list",
        "file": "deprecated.mbt",
        "line": 34,
        "column": 8
      }
    },
    {
      "name": "intercalate",
      "docstring": "\n Similar to intersperse but with a list of values.\n\n # Example\n ```\n let ls = @list.of([\n    @list.of([1, 2, 3]),\n    @list.of([4, 5, 6]),\n    @list.of([7, 8, 9]),\n ])\n let r = ls.intercalate(@list.of([0]))\n assert_eq!(r, @list.of([1, 2, 3, 0, 4, 5, 6, 0, 7, 8, 9]))\n ```",
      "signature": "fn intercalate[A](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[<a href=\"moonbitlang/core/immut/list#T\">T</a>[A]], sep : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A]) -> <a href=\"moonbitlang/core/immut/list#T\">T</a>[A]",
      "loc": {
        "path": "moonbitlang/core/immut/list",
        "file": "list.mbt",
        "line": 1029,
        "column": 8
      }
    },
    {
      "name": "intersperse",
      "docstring": "\n Insert separator to the list.\n\n # Example\n\n ```\n let ls = @list.intersperse(@list.from_array([\"1\", \"2\", \"3\", \"4\", \"5\"]), \"|\")\n assert_eq!(ls, @list.from_array([\"1\", \"|\", \"2\", \"|\", \"3\", \"|\", \"4\", \"|\", \"5\"]))\n ```",
      "signature": "fn intersperse[A](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A], separator : A) -> <a href=\"moonbitlang/core/immut/list#T\">T</a>[A]",
      "loc": {
        "path": "moonbitlang/core/immut/list",
        "file": "list.mbt",
        "line": 594,
        "column": 8
      }
    },
    {
      "name": "is_empty",
      "docstring": "\n Check if the list is empty.",
      "signature": "fn is_empty[A](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A]) -> Bool",
      "loc": {
        "path": "moonbitlang/core/immut/list",
        "file": "list.mbt",
        "line": 605,
        "column": 8
      }
    },
    {
      "name": "is_prefix",
      "docstring": "\n Returns true if list starts with prefix.\n\n # Example\n\n ```\n assert_eq!(@list.of([1, 2, 3, 4, 5]).is_prefix(@list.of([1, 2, 3])), true)\n ```",
      "signature": "fn is_prefix[A : <a href=\"moonbitlang/core/builtin#Eq\">Eq</a>](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A], prefix : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A]) -> Bool",
      "loc": {
        "path": "moonbitlang/core/immut/list",
        "file": "list.mbt",
        "line": 996,
        "column": 8
      }
    },
    {
      "name": "is_suffix",
      "docstring": "\n Returns true if list ends with suffix.\n\n # Example\n\n ```\n assert_eq!(@list.of([1, 2, 3, 4, 5]).is_suffix(@list.of([3, 4, 5])), true)\n ```",
      "signature": "fn is_suffix[A : <a href=\"moonbitlang/core/builtin#Eq\">Eq</a>](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A], suffix : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A]) -> Bool",
      "loc": {
        "path": "moonbitlang/core/immut/list",
        "file": "list.mbt",
        "line": 1012,
        "column": 8
      }
    },
    {
      "name": "iter",
      "docstring": "",
      "signature": "fn iter[A](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A]) -> <a href=\"moonbitlang/core/builtin#Iter\">Iter</a>[A]",
      "loc": {
        "path": "moonbitlang/core/immut/list",
        "file": "list.mbt",
        "line": 1045,
        "column": 8
      }
    },
    {
      "name": "iter2",
      "docstring": "",
      "signature": "fn iter2[A](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A]) -> <a href=\"moonbitlang/core/builtin#Iter2\">Iter2</a>[Int, A]",
      "loc": {
        "path": "moonbitlang/core/immut/list",
        "file": "list.mbt",
        "line": 1060,
        "column": 8
      }
    },
    {
      "name": "last",
      "docstring": "\n Last element of the list.\n\n # Example\n\n ```\n assert_eq!(@list.of([1, 2, 3, 4, 5]).last(), Some(5))\n ```",
      "signature": "fn last[A](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A]) -> A?",
      "loc": {
        "path": "moonbitlang/core/immut/list",
        "file": "list.mbt",
        "line": 290,
        "column": 8
      }
    },
    {
      "name": "length",
      "docstring": "\n Get the length of the list.",
      "signature": "fn length[A](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A]) -> Int",
      "loc": {
        "path": "moonbitlang/core/immut/list",
        "file": "list.mbt",
        "line": 77,
        "column": 8
      }
    },
    {
      "name": "lookup",
      "docstring": "\n Looks up a key in an association list.\n\n # Example\n\n ```\n let ls = @list.from_array([(1, \"a\"), (2, \"b\"), (3, \"c\")])\n assert_eq!(ls.lookup(3), Some(\"c\"))\n ```",
      "signature": "fn lookup[A : <a href=\"moonbitlang/core/builtin#Eq\">Eq</a>, B](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[(A, B)], v : A) -> B?",
      "loc": {
        "path": "moonbitlang/core/immut/list",
        "file": "list.mbt",
        "line": 899,
        "column": 8
      }
    },
    {
      "name": "map",
      "docstring": "\n Maps the list.\n\n # Example\n\n ```\n assert_eq!(@list.of([1, 2, 3, 4, 5]).map(fn(x){ x * 2}), @list.of([2, 4, 6, 8, 10]))\n ```",
      "signature": "fn map[A, B](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A], f : (A) -> B) -> <a href=\"moonbitlang/core/immut/list#T\">T</a>[B]",
      "loc": {
        "path": "moonbitlang/core/immut/list",
        "file": "list.mbt",
        "line": 132,
        "column": 8
      }
    },
    {
      "name": "mapi",
      "docstring": "\n Maps the list with index.",
      "signature": "fn mapi[A, B](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A], f : (Int, A) -> B) -> <a href=\"moonbitlang/core/immut/list#T\">T</a>[B]",
      "loc": {
        "path": "moonbitlang/core/immut/list",
        "file": "list.mbt",
        "line": 141,
        "column": 8
      }
    },
    {
      "name": "maximum",
      "docstring": "\n Get maximum element of the list.\n Returns None if the list is empty.",
      "signature": "fn maximum[A : <a href=\"moonbitlang/core/builtin#Compare\">Compare</a> + <a href=\"moonbitlang/core/builtin#Eq\">Eq</a>](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A]) -> A?",
      "loc": {
        "path": "moonbitlang/core/immut/list",
        "file": "list.mbt",
        "line": 669,
        "column": 8
      }
    },
    {
      "name": "minimum",
      "docstring": "\n Get minimum element of the list.",
      "signature": "fn minimum[A : <a href=\"moonbitlang/core/builtin#Compare\">Compare</a> + <a href=\"moonbitlang/core/builtin#Eq\">Eq</a>](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A]) -> A?",
      "loc": {
        "path": "moonbitlang/core/immut/list",
        "file": "list.mbt",
        "line": 700,
        "column": 8
      }
    },
    {
      "name": "nth",
      "docstring": "\n Get nth element of the list or None if the index is out of bounds",
      "signature": "fn nth[A](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A], n : Int) -> A?",
      "loc": {
        "path": "moonbitlang/core/immut/list",
        "file": "list.mbt",
        "line": 561,
        "column": 8
      }
    },
    {
      "name": "nth_exn",
      "docstring": "",
      "signature": "fn nth_exn[A](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A], n : Int) -> A",
      "loc": {
        "path": "moonbitlang/core/immut/list",
        "file": "list.mbt",
        "line": 555,
        "column": 8
      }
    },
    {
      "name": "of",
      "docstring": "",
      "signature": "fn of[A](arr : <a href=\"moonbitlang/core/array#FixedArray\">FixedArray</a>[A]) -> <a href=\"moonbitlang/core/immut/list#T\">T</a>[A]",
      "loc": {
        "path": "moonbitlang/core/immut/list",
        "file": "list.mbt",
        "line": 1088,
        "column": 8
      }
    },
    {
      "name": "remove",
      "docstring": "\n Removes the first occurrence of the specified element from the list, if it is present.\n\n # Example\n\n ```\n assert_eq!(@list.of([1, 2, 3, 4, 5]).remove(3), @list.of([1, 2, 4, 5]))\n ```",
      "signature": "fn remove[A : <a href=\"moonbitlang/core/builtin#Eq\">Eq</a>](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A], elem : A) -> <a href=\"moonbitlang/core/immut/list#T\">T</a>[A]",
      "loc": {
        "path": "moonbitlang/core/immut/list",
        "file": "list.mbt",
        "line": 976,
        "column": 8
      }
    },
    {
      "name": "remove_at",
      "docstring": "\n Removes the element at the specified index in the list.\n\n # Example\n\n ```\n assert_eq!(@list.of([1, 2, 3, 4, 5]).remove_at(2), @list.of([1, 2, 4, 5]))\n ```",
      "signature": "fn remove_at[A](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A], index : Int) -> <a href=\"moonbitlang/core/immut/list#T\">T</a>[A]",
      "loc": {
        "path": "moonbitlang/core/immut/list",
        "file": "list.mbt",
        "line": 959,
        "column": 8
      }
    },
    {
      "name": "repeat",
      "docstring": "\n Create a list of length n with the given value\n\n # Example\n\n ```\n assert_eq!(@list.repeat(5, 1), @list.from_array([1, 1, 1, 1, 1]))\n ```",
      "signature": "fn repeat[A](n : Int, x : A) -> <a href=\"moonbitlang/core/immut/list#T\">T</a>[A]",
      "loc": {
        "path": "moonbitlang/core/immut/list",
        "file": "list.mbt",
        "line": 577,
        "column": 8
      }
    },
    {
      "name": "rev",
      "docstring": "\n Reverse the list.\n\n # Example\n\n ```\n assert_eq!(@list.of([1, 2, 3, 4, 5]).rev(), @list.of([5, 4, 3, 2, 1]))\n ```",
      "signature": "fn rev[A](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A]) -> <a href=\"moonbitlang/core/immut/list#T\">T</a>[A]",
      "loc": {
        "path": "moonbitlang/core/immut/list",
        "file": "list.mbt",
        "line": 338,
        "column": 8
      }
    },
    {
      "name": "rev_concat",
      "docstring": "\n Reverse the first list and concatenate it with the second.\n\n # Example\n\n ```\n let ls = @list.of([1, 2, 3, 4, 5]).rev_concat(@list.of([6, 7, 8, 9, 10]))\n assert_eq!(ls, @list.of([5, 4, 3, 2, 1, 6, 7, 8, 9, 10]))\n ```",
      "signature": "fn rev_concat[A](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A], other : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A]) -> <a href=\"moonbitlang/core/immut/list#T\">T</a>[A]",
      "loc": {
        "path": "moonbitlang/core/immut/list",
        "file": "list.mbt",
        "line": 323,
        "column": 8
      }
    },
    {
      "name": "rev_fold",
      "docstring": "\n Fold the list from right.\n\n # Example\n ```\n let r = @list.of([1, 2, 3, 4, 5]).rev_fold(fn(x, acc) { x + acc }, init=0)\n assert_eq!(r, 15)\n ```",
      "signature": "fn rev_fold[A, B](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A], init~ : B, f : (A, B) -> B) -> B",
      "loc": {
        "path": "moonbitlang/core/immut/list",
        "file": "list.mbt",
        "line": 366,
        "column": 8
      }
    },
    {
      "name": "rev_foldi",
      "docstring": "\n Fold the list from right with index.",
      "signature": "fn rev_foldi[A, B](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A], init~ : B, f : (Int, A, B) -> B) -> B",
      "loc": {
        "path": "moonbitlang/core/immut/list",
        "file": "list.mbt",
        "line": 420,
        "column": 8
      }
    },
    {
      "name": "rev_map",
      "docstring": "\n Maps the list and reverses the result.\n\n `list.rev_map(f)` is equivalent to `list.map(f).rev()` but more efficient.\n\n # Example\n ```\n assert_eq!(@list.of([1, 2, 3, 4, 5]).rev_map(fn(x) { x * 2 }), @list.of([10, 8, 6, 4, 2]))\n ```",
      "signature": "fn rev_map[A, B](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A], f : (A) -> B) -> <a href=\"moonbitlang/core/immut/list#T\">T</a>[B]",
      "loc": {
        "path": "moonbitlang/core/immut/list",
        "file": "list.mbt",
        "line": 161,
        "column": 8
      }
    },
    {
      "name": "scan_left",
      "docstring": "\n Fold a list and return a list of successive reduced values from the left\n\n # Example\n\n ```\n let ls = @list.of([1, 2, 3, 4, 5])\n let r = ls.scan_left(fn(acc, x) { acc + x }, init=0)\n assert_eq!(r, @list.of([0, 1, 3, 6, 10, 15]))\n ```",
      "signature": "fn scan_left[A, E](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A], f : (E, A) -> E, init~ : E) -> <a href=\"moonbitlang/core/immut/list#T\">T</a>[E]",
      "loc": {
        "path": "moonbitlang/core/immut/list",
        "file": "list.mbt",
        "line": 859,
        "column": 8
      }
    },
    {
      "name": "scan_right",
      "docstring": "\n Fold a list and return a list of successive reduced values from the right\n\n Note that the order of parameters on the accumulating function are reversed.\n\n # Example\n ```\n let ls = @list.of([1, 2, 3, 4, 5])\n let r = ls.scan_right(fn(x, acc) { acc + x }, init=0)\n assert_eq!(r, @list.of([15, 14, 12, 9, 5, 0]))\n ```",
      "signature": "fn scan_right[A, B](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A], f : (A, B) -> B, init~ : B) -> <a href=\"moonbitlang/core/immut/list#T\">T</a>[B]",
      "loc": {
        "path": "moonbitlang/core/immut/list",
        "file": "list.mbt",
        "line": 880,
        "column": 8
      }
    },
    {
      "name": "singleton",
      "docstring": "",
      "signature": "fn singleton[A](x : A) -> <a href=\"moonbitlang/core/immut/list#T\">T</a>[A]",
      "loc": {
        "path": "moonbitlang/core/immut/list",
        "file": "list.mbt",
        "line": 1105,
        "column": 8
      }
    },
    {
      "name": "sort",
      "docstring": "\n Sort the list in ascending order.\n\n # Example\n\n ```\n let ls = @list.sort(@list.from_array([1,123,52,3,6,0,-6,-76]))\n assert_eq!(ls, @list.from_array([-76, -6, 0, 1, 3, 6, 52, 123]))\n ```",
      "signature": "fn sort[A : <a href=\"moonbitlang/core/builtin#Compare\">Compare</a> + <a href=\"moonbitlang/core/builtin#Eq\">Eq</a>](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A]) -> <a href=\"moonbitlang/core/immut/list#T\">T</a>[A]",
      "loc": {
        "path": "moonbitlang/core/immut/list",
        "file": "list.mbt",
        "line": 721,
        "column": 8
      }
    },
    {
      "name": "tail",
      "docstring": "\n Tail of the list.\n\n # Example\n\n ```\n assert_eq!(@list.of([1, 2, 3, 4, 5]).tail(), @list.of([2, 3, 4, 5]))\n ```",
      "signature": "fn tail[A](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A]) -> <a href=\"moonbitlang/core/immut/list#T\">T</a>[A]",
      "loc": {
        "path": "moonbitlang/core/immut/list",
        "file": "list.mbt",
        "line": 233,
        "column": 8
      }
    },
    {
      "name": "take",
      "docstring": "\n Take first n elements of the list.\n If the list is shorter than n, return the whole list.\n\n # Example\n\n ```\n let ls = @list.of([1, 2, 3, 4, 5])\n let r = ls.take(3)\n assert_eq!(r, @list.of([1, 2, 3]))\n ```",
      "signature": "fn take[A](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A], n : Int) -> <a href=\"moonbitlang/core/immut/list#T\">T</a>[A]",
      "loc": {
        "path": "moonbitlang/core/immut/list",
        "file": "list.mbt",
        "line": 776,
        "column": 8
      }
    },
    {
      "name": "take_while",
      "docstring": "\n Take the longest prefix of a list of elements that satisfies a given predicate.\n\n # Example\n\n ```\n let ls = @list.from_array([1, 2, 3, 4])\n let r = ls.take_while(fn(x) { x < 3 })\n assert_eq!(r, @list.of([1, 2]))\n ```",
      "signature": "fn take_while[A](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A], p : (A) -> Bool) -> <a href=\"moonbitlang/core/immut/list#T\">T</a>[A]",
      "loc": {
        "path": "moonbitlang/core/immut/list",
        "file": "list.mbt",
        "line": 825,
        "column": 8
      }
    },
    {
      "name": "to_array",
      "docstring": "\n Convert list to array.",
      "signature": "fn to_array[A](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A]) -> <a href=\"moonbitlang/core/array#Array\">Array</a>[A]",
      "loc": {
        "path": "moonbitlang/core/immut/list",
        "file": "list.mbt",
        "line": 170,
        "column": 8
      }
    },
    {
      "name": "to_json",
      "docstring": "",
      "signature": "fn to_json[A : <a href=\"moonbitlang/core/builtin#ToJson\">ToJson</a>](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A]) -> <a href=\"moonbitlang/core/json#Json\">Json</a>",
      "loc": {
        "path": "moonbitlang/core/immut/list",
        "file": "list.mbt",
        "line": 37,
        "column": 8
      }
    },
    {
      "name": "unfold",
      "docstring": "\n Produces a collection iteratively.\n\n # Example\n\n ```\n let r = @list.unfold(init=0, fn { i => if i == 3 { None } else { Some((i, i + 1)) } })\n assert_eq!(r, @list.from_array([0, 1, 2]))\n ```",
      "signature": "fn unfold[A, S](f : (S) -> (A, S)?, init~ : S) -> <a href=\"moonbitlang/core/immut/list#T\">T</a>[A]",
      "loc": {
        "path": "moonbitlang/core/immut/list",
        "file": "list.mbt",
        "line": 758,
        "column": 8
      }
    },
    {
      "name": "unsafe_head",
      "docstring": "\n Get first element of the list.\n @alert unsafe \"Panic if the list is empty\"",
      "signature": "fn unsafe_head[A](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A]) -> A",
      "loc": {
        "path": "moonbitlang/core/immut/list",
        "file": "list.mbt",
        "line": 243,
        "column": 8
      }
    },
    {
      "name": "unsafe_last",
      "docstring": "\n @alert unsafe \"Panic if the list is empty\"",
      "signature": "fn unsafe_last[A](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A]) -> A",
      "loc": {
        "path": "moonbitlang/core/immut/list",
        "file": "list.mbt",
        "line": 274,
        "column": 8
      }
    },
    {
      "name": "unsafe_maximum",
      "docstring": "\n @alert unsafe \"Panic if the list is empty\"",
      "signature": "fn unsafe_maximum[A : <a href=\"moonbitlang/core/builtin#Compare\">Compare</a> + <a href=\"moonbitlang/core/builtin#Eq\">Eq</a>](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A]) -> A",
      "loc": {
        "path": "moonbitlang/core/immut/list",
        "file": "list.mbt",
        "line": 651,
        "column": 8
      }
    },
    {
      "name": "unsafe_minimum",
      "docstring": "\n @alert unsafe \"Panic if the list is empty\"",
      "signature": "fn unsafe_minimum[A : <a href=\"moonbitlang/core/builtin#Compare\">Compare</a> + <a href=\"moonbitlang/core/builtin#Eq\">Eq</a>](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A]) -> A",
      "loc": {
        "path": "moonbitlang/core/immut/list",
        "file": "list.mbt",
        "line": 683,
        "column": 8
      }
    },
    {
      "name": "unsafe_nth",
      "docstring": "\n @alert unsafe \"Panic if the index is out of bounds\"",
      "signature": "fn unsafe_nth[A](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A], n : Int) -> A",
      "loc": {
        "path": "moonbitlang/core/immut/list",
        "file": "list.mbt",
        "line": 544,
        "column": 8
      }
    },
    {
      "name": "unzip",
      "docstring": "\n Unzip two lists.\n\n # Example\n\n ```\n let (a,b) = @list.unzip(@list.from_array([(1,2),(3,4),(5,6)]))\n assert_eq!(a, @list.from_array([1, 3, 5]))\n assert_eq!(b, @list.from_array([2, 4, 6]))\n ```",
      "signature": "fn unzip[A, B](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[(A, B)]) -> (<a href=\"moonbitlang/core/immut/list#T\">T</a>[A], <a href=\"moonbitlang/core/immut/list#T\">T</a>[B])",
      "loc": {
        "path": "moonbitlang/core/immut/list",
        "file": "list.mbt",
        "line": 619,
        "column": 8
      }
    },
    {
      "name": "zip",
      "docstring": "\n Zip two lists.\n If the lists have different lengths, it will return None.\n\n # Example\n\n ```\n let r = @list.zip(@list.of([1, 2, 3, 4, 5]), @list.of([6, 7, 8, 9, 10]))\n assert_eq!(r, Some(@list.from_array([(1, 6), (2, 7), (3, 8), (4, 9), (5, 10)])))\n ```",
      "signature": "fn zip[A, B](self : <a href=\"moonbitlang/core/immut/list#T\">T</a>[A], other : <a href=\"moonbitlang/core/immut/list#T\">T</a>[B]) -> <a href=\"moonbitlang/core/immut/list#T\">T</a>[(A, B)]?",
      "loc": {
        "path": "moonbitlang/core/immut/list",
        "file": "list.mbt",
        "line": 471,
        "column": 8
      }
    }
  ],
  "misc": []
}