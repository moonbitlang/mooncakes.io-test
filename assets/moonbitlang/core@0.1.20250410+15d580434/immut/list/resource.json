{
  "kind": "package",
  "relative_path": "immut/list",
  "module_path": "moonbitlang/core",
  "readme_content": "---\nmoonbit : true\n---\n\n# Immutable List\n\nList is implemented as a **linked list**, supporting O(1) head access.\n- Moonbit list is **homogeneous** list, which means all elements in the list must be of the same type.\n- Moonbit list does not support random access well, you can only access elements by iterating through the list. If you need randomly access the nth element, you should use `Array` instead.\n\n# Usage\n\n## Building lists \n\nYou can create a list manually via the `default()` or construct it using the `of()` method: \n```moonbit\nlet list0 : @list.T[Int] = @list.default()\nassert_eq!(list0.length(), 0)\nlet list1 = @list.of([1, 2, 3, 4, 5])\nassert_eq!(list1.length(), 5)\n```\n\nOr use `Cons` constructor directly (Adds a single element to the beginning of a list):\n```moonbit\nlet list = @list.Cons(1, Cons(2, Cons(3, Nil)))\nassert_eq!(list.to_array(), [1, 2, 3])\n```\n\nBuild a repeated list by using the `repeat()` method:\n```moonbit\nassert_eq!(@list.repeat(3, 1).to_array(), [1, 1, 1])\n```\n\n## Pattern matching\nYou can use pattern matching to destructure a list:\n```moonbit\nlet list = @list.of([1, 2, 3, 4, 5])\nlet arr = []\nmatch list {\n    Cons(head, _tail) => arr.push(head)\n    Nil => println(\"Empty list\")\n}\nassert_eq!(arr, [1])\n```\n\n## Iterating over a list\nThe standard library provides a lot of tools for iterating over a list, such as `each()`, `eachi()`, etc. (For details check the API documentation)\n```moonbit\nlet list = @list.of([1, 2, 3, 4, 5])\nlet arr = []\nlist.each(fn (ele) { arr.push(ele) }) \nassert_eq!(arr, [1, 2, 3, 4, 5])\n```\n\n## Appending / Joining lists\nTo simply concatenate two lists, you can use the `concat()` method (or `+` operator):\n```moonbit\nlet list1 = @list.of([1, 2, 3])\nlet list2 = @list.of([4, 5, 6])\nlet list3 = list1.concat(list2)\nlet list4 = list1 + list2\nassert_eq!(list3.to_array(), [1, 2, 3, 4, 5, 6])\nassert_eq!(list4.to_array(), [1, 2, 3, 4, 5, 6])\n```\n\nFor concatenating multiple lists (especially the length is unknown), you can use the `flatten()` method:\n```moonbit\nlet ls1 = @list.of([1, 2, 3])\nlet ls2 = @list.of([4, 5, 6])\nlet ls3 = @list.of([7, 8, 9])\nlet ls4 = @list.of([ls1, ls2, ls3])\nassert_eq!(ls4.flatten().to_array(), [1, 2, 3, 4, 5, 6, 7, 8, 9])\n```\n\nTo insert separate elements into a list, you can use the `intersperse()` method:\n\n```moonbit\nlet list = @list.of([1, 2, 3])\nassert_eq!(list.intersperse(0).to_array(), [1, 0, 2, 0, 3])\n```\n\n## Filtering / Rejecting / Selecting elements\nThere are three ways to filter / reject / select multiple elements from a list:\n- Go through the entire list and decide whether the element should be present in the resultant list or not. Use `filter` for this.\n- To extract the first (or last) N elements of a list (and N is independent of the contents of the list). Use `take` or `drop` in this case.\n- To stop selecting elements (terminate the iteration) as soon as a condition is met, using `take_while` or `drop_while`\n\n```moonbit\nlet ls = @list.of([1, 2, 3, 4, 5])\nassert_eq!(ls.filter(fn (ele) { ele % 2 == 0 }).to_array(), [2, 4])\nassert_eq!(ls.take(2).to_array(), [1, 2])\nassert_eq!(ls.drop(2).to_array(), [3, 4, 5])\nassert_eq!(ls.take_while(fn (ele) { ele < 3 }).to_array(), [1, 2])\nassert_eq!(ls.drop_while(fn (ele) { ele < 3 }).to_array(), [3, 4, 5])\n```\n\n## Accessing elements / sub-lists\nYou can access the head of the list using the `head()` (O(1)) method. It returns `Some(head)` or `None` if the list is empty.\nAnd access the last element using the `last()` method (O(n)). \n\n```moonbit\nlet list = @list.of([1, 2, 3, 4, 5])\nassert_eq!(list.head(), Some(1))\nassert_eq!(list.last(), Some(5))\n```\n\nFor randomly accessing, you can use the `nth()` method, which returns the nth element in the list (O(n)). \nIf the index is out of bounds, it returns `None`.\n```moonbit\nlet list = @list.of([1, 2, 3, 4, 5])\nassert_eq!(list.nth(2), Some(3))\nassert_eq!(list.nth(8), None)\n```\n\nTo get a sub-list from the list, you can use the `init_()` method for getting all elements except the last one, and `tail()` for getting all elements except the first one.\n```moonbit\nlet list = @list.of([1, 2, 3, 4, 5])\nassert_eq!(list.init_().to_array(), [1, 2, 3, 4])\nassert_eq!(list.tail().to_array(), [2, 3, 4, 5])\n```\n\n## Reducing Lists\nYou can reduce (fold) a list to a single value using the `fold()` method.\n```moonbit\nlet list = @list.of([1, 2, 3, 4, 5])\nassert_eq!(list.fold(init=0, fn(acc, x) { acc + x }), 15)\n```\n\nThere are some special folds that you can use like `any`, `all`, `sum`, `maximum`, and `minimum`. Check the API documentation below for more details.\n\n## List transformations\nTo transform list elements, you can use the `map()` method.\n```moonbit\nlet list = @list.of([1, 2, 3, 4, 5])\nassert_eq!(list.map(fn (ele) { ele * 2 }).to_array(), [2, 4, 6, 8, 10])\n```\n\nThe `rev` method reverses the list.\n```moonbit\nlet list = @list.of([1, 2, 3, 4, 5])\nassert_eq!(list.rev().to_array(), [5, 4, 3, 2, 1])\n```",
  "package_data": "moonbitlang/core/immut/list/package_data.json",
  "source_files": [ "list.mbt", "deprecated.mbt", "types.mbt" ]
}