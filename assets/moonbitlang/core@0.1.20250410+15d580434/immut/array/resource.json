{
  "kind": "package",
  "relative_path": "immut/array",
  "module_path": "moonbitlang/core",
  "readme_content": "---\nmoonbit : true\n---\n\n# Immutable Array\n\nImmutable array is a persistent data structure that provides random access and update operations. Based on Clojure's [persistent vector](https://hypirion.com/musings/understanding-persistent-vector-pt-1).\n\n# Usage\n\n## Create\n\nYou can create an empty array using `new()` or construct it using `of()`, or use `from_iter()` to construct it from an iterator.\n\n```moonbit\nlet _arr1 = @array.of([1, 2, 3, 4, 5])    \nlet _arr2 : @array.T[Int] = @array.new()\nlet _arr3 = @array.from_iter((1).until(5))\nlet _arr4 = @array.from_array([1, 2, 3])\n```\n\nOr use `make()`, `makei()` to create an array with some elements.\n\n```moonbit\nlet arr1 = @array.make(5, 1)\nassert_eq!(arr1.to_array(), [1, 1, 1, 1, 1])\nlet arr2 = @array.makei(5, fn(i){i + 1})\nassert_eq!(arr2.to_array(), [1, 2, 3, 4, 5])\n```\n\n## Update \n\nSince the array is immutable, the `set()`, `push()` operation is not in-place. It returns a new array with the updated value.\n\n```moonbit\nlet arr1 = @array.of([1, 2, 3, 4, 5])\nlet arr2 = arr1.set(2, 10).push(6)\nassert_eq!(arr1.to_array(), [1, 2, 3, 4, 5])\nassert_eq!(arr2.to_array(), [1, 2, 10, 4, 5, 6])\n```\n\n## Concatenation\n\nYou can use `concat()` to concatenate two arrays.\n\n```moonbit\nlet arr1 = @array.of([1, 2, 3])\nlet arr2 = @array.of([4, 5, 6])\nlet arr3 = arr1.concat(arr2)\nassert_eq!(arr3.to_array(), [1, 2, 3, 4, 5, 6])\n```\n\n## Query\n\nYou can use `op_get()` to get the value at the index, or `length()` to get the length of the array, or `is_empty()` to check whether the array is empty.\n\n```moonbit\nlet arr = @array.of([1, 2, 3, 4, 5])\nassert_eq!(arr[2], 3)\nassert_eq!(arr.length(), 5)\nassert_eq!(arr.is_empty(), false)\n```\n\n## Iteration\n\nYou can use `iter()` to get an iterator of the array, or use `each()` to iterate over the array.\n\n```moonbit\nlet arr = @array.of([1, 2, 3, 4, 5])\ninspect!(arr.iter(), content=\"[1, 2, 3, 4, 5]\")\nlet val = []\narr.each(fn(v) { val.push(v) })\nassert_eq!(val, [1, 2, 3, 4, 5])\nlet vali = []\narr.eachi(fn(i, v) { vali.push((i, v)) })\nassert_eq!(vali, [(0, 1), (1, 2), (2, 3), (3, 4), (4, 5)])\n```\n\n# TODO\n\n- [] Add `split` and other operations that can be derived from `split` and `concat` like `insert` and `delete`.\n- [] Add an algorithm description in README, since this algorithm does not use the invariant in the ICFP paper. Instead, it uses the \"search step invariant\" in Hypirion's thesis.\n- [] Add a benchmark to compare the performance with the previous version.\n- [] Optimizations such as tail.\n",
  "package_data": "moonbitlang/core/immut/array/package_data.json",
  "source_files": [
    "tree_utils.mbt", "array.mbt", "deprecated.mbt", "utils.mbt",
    "types.mbt", "tree.mbt"
  ]
}