{
  "kind": "package",
  "relative_path": "immut/sorted_map",
  "module_path": "moonbitlang/core",
  "readme_content": "---\nmoonbit : true\n---\n\n# Immutable Map\n\nAn immutable tree map based on size balanced tree.\n\n# Usage\n\n## Create\n\nYou can create an empty map using `new()` or construct it with a single key-value pair using `singleton()`.\n\n```moonbit\nlet map1 : @sorted_map.T[String, Int] = @sorted_map.new()\nlet map2 = @sorted_map.singleton(\"a\", 1)\nassert_eq!(map1.size(), 0)\nassert_eq!(map2.size(), 1)\n```\n\nAlso, you can construct it from an array using `of()` or `from_array()`.\n\n```moonbit\nlet map = @sorted_map.of([(\"a\", 1), (\"b\", 2), (\"c\", 3)])\nassert_eq!(map.elems(), [1, 2, 3])\nassert_eq!(map.keys(), [\"a\", \"b\", \"c\"])\n```\n\n## Insert & Lookup\n\nYou can use `add()` to add a key-value pair to the map and create a new map. Or use `lookup()` to get the value associated with a key.\n\n```moonbit\nlet map : @sorted_map.T[String,Int] = @sorted_map.new()\nlet map = map.add(\"a\", 1)\nassert_eq!(map.lookup(\"a\"), Some(1))\n```\n\n## Remove\n\nYou can use `remove()` to remove a key-value pair from the map.\n\n```moonbit\nlet map = @sorted_map.of([(\"a\", 1), (\"b\", 2), (\"c\", 3)])\nlet map = map.remove(\"a\")\nassert_eq!(map.lookup(\"a\"), None)\n```\n\n## Contains\n\nYou can use `contains()` to check whether a key exists.\n\n```moonbit\nlet map = @sorted_map.of([(\"a\", 1), (\"b\", 2), (\"c\", 3)])\nassert_eq!(map.contains(\"a\"), true)\nassert_eq!(map.contains(\"d\"), false)\n```\n\n## Size\n\nYou can use `size()` to get the number of key-value pairs in the map.\n\n```moonbit\nlet map = @sorted_map.of([(\"a\", 1), (\"b\", 2), (\"c\", 3)])\nassert_eq!(map.size(), 3)\n```\n\nSimilarly, you can use `is_empty()` to check whether the map is empty.\n\n```moonbit\nlet map : @sorted_map.T[String, Int] = @sorted_map.new()\nassert_eq!(map.is_empty(), true)\n```\n\n## Traversal\n\nUse `each()` or `eachi()` to iterate through all key-value pairs.\n\n```moonbit\nlet map = @sorted_map.of([(\"a\", 1), (\"b\", 2), (\"c\", 3)])\nlet arr = []\nmap.each(fn(k, v) { arr.push(\"key:\\{k}, value:\\{v}\") })\nassert_eq!(arr, [\"key:a, value:1\", \"key:b, value:2\", \"key:c, value:3\"])\nlet arr = []\nmap.eachi(fn(i, k, v) { arr.push(\"index:\\{i}, key:\\{k}, value:\\{v}\") })\nassert_eq!(arr, [\"index:0, key:a, value:1\", \"index:1, key:b, value:2\", \"index:2, key:c, value:3\"])\n```\n\nUse `map()` or `map_with_key()` to map a function over all values.\n\n```moonbit\nlet map = @sorted_map.of([(\"a\", 1), (\"b\", 2), (\"c\", 3)])\nlet map = map.map(fn(v) { v + 1 })\nassert_eq!(map.elems(), [2, 3, 4])\nlet map = map.map_with_key(fn(_k, v) { v + 1 })\nassert_eq!(map.elems(), [3, 4, 5])\n```\n\nUse `fold()` or `foldl_with_key()` to fold the values in the map. The default order of fold is Pre-order.\nSimilarly, you can use `foldr_with_key()` to do a Post-order fold.\n\n```moonbit\nlet map = @sorted_map.of([(\"a\", 1), (\"b\", 2), (\"c\", 3)])\nassert_eq!(map.fold(fn (acc, v) { acc + v }, init=0), 6) // 6\nassert_eq!(map.foldl_with_key(fn (acc, k, v) { acc + k + v.to_string() }, init=\"\"), \"a1b2c3\") // \"a1b2c3\"\nassert_eq!(map.foldr_with_key(fn (acc, k, v) { acc + k + v.to_string() }, init=\"\"), \"c3b2a1\") // \"c3b2a1\"\n```\n\nUse `filter()` or `filter_with_key()` to filter all keys/values that satisfy the predicate.\n\n```moonbit\nlet map = @sorted_map.of([(\"a\", 1), (\"b\", 2), (\"c\", 3)])\nlet map = map.filter(fn (v) { v > 1 })\nassert_eq!(map.elems(), [2, 3])\nassert_eq!(map.keys(), [\"b\", \"c\"])\n\nlet map = map.filter_with_key(fn (k, v) { k > \"a\" && v > 1 })\nassert_eq!(map.elems(), [2, 3])\nassert_eq!(map.keys(), [\"b\", \"c\"])\n```\n\n## Conversion\n\nUse `elems()` to get all values in ascending order of their keys.\n\n```moonbit\nlet map = @sorted_map.of([(\"a\", 1), (\"b\", 2), (\"c\", 3)])\nlet elems = map.elems() // [1, 2, 3]\nassert_eq!(elems, [1, 2, 3])\n```\n\nUse `keys()` to get all keys of the map in ascending order.\n\n```moonbit\nlet map = @sorted_map.of([(\"a\", 1), (\"b\", 2), (\"c\", 3)])\nlet keys = map.keys() // [\"a\", \"b\", \"c\"]\nassert_eq!(keys, [\"a\", \"b\", \"c\"])\n```\n\n",
  "package_data": "moonbitlang/core/immut/sorted_map/package_data.json",
  "source_files": [
    "map.mbt", "traits_impl.mbt", "deprecated.mbt", "utils.mbt", "types.mbt",
    "inorder_iterator.mbt"
  ]
}