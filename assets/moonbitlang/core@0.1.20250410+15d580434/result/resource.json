{
  "kind": "package",
  "relative_path": "result",
  "module_path": "moonbitlang/core",
  "readme_content": "---\nmoonbit : true\n---\n\n# Moonbit/Core Result\n\n## Overview\n`Result[T,E]` is a type used for handling computation results and errors in an explicit and declarative manner, similar to Rust (`Result<T,E>`) and OCaml (`('a, 'e) result`). \nIt is an enum with two variants: `Ok(T)`, which represents success and contains a value of type `T`, and `Err(E)`, representing error and containing an error value of type `E`. \n```moonbit skip\nenum Result[T, E] {\n    Ok(T)\n    Err(E)\n}\n```\n\n## Usage\n### Constructing Result\nYou can create a `Result` value using the `Ok` and `Err` constructors, remember to give proper type annotations.\n```moonbit\nlet _result: Result[Int, String] = Ok(42)\nlet _error: Result[Int, String] = Err(\"Error message\")\n```\n\nOr use the `ok` and `err` functions to create a `Result` value.\n```moonbit\nlet _result : Result[String, Unit] = ok(\"yes\")\nlet _error : Result[Int, String] = err(\"error\")\n```\n\n### Querying variant\nYou can check the variant of a `Result` using the `is_ok` and `is_err` methods.\n```moonbit\nlet result: Result[Int, String] = Ok(42)\nlet is_ok = result.is_ok()\nassert_eq!(is_ok, true)\nlet is_err = result.is_err()\nassert_eq!(is_err, false)\n```\n\n### Extracting values\nYou can extract the value from a `Result` using the `match` expression (Pattern Matching).\n```moonbit\nlet result : Result[Int, Unit] = Ok(33)\nlet val = match result {\n    Ok(value) => value\n    Err(_) => -1\n}\nassert_eq!(val, 33)\n```\n\nOr using the `unwrap` method, which will panic if the result is `Err` and return the value if it is `Ok`.\n```moonbit\nlet result: Result[Int, String] = Ok(42)\nlet value = result.unwrap()\nassert_eq!(value, 42)\n```\n\nA safe alternative is the `or` method, which returns the value if the result is `Ok` or a default value if it is `Err`.\n```moonbit\nlet result: Result[Int, String] = Err(\"error\")\nlet value = result.or(0)\nassert_eq!(value, 0)\n```\n\nThere is a lazy version of `or` called `or_else`, which takes a function that returns a default value.\n```moonbit\nlet result: Result[Int, String] = Err(\"error\")\nlet value = result.or_else(fn() { 0 })\nassert_eq!(value, 0)\n```\n\n### Transforming values\nTo transform values inside a `Result`, you can use the `map` method, which applies a function to the value if the result is `Ok`,\nand remains unchanged if it is `Err`.\n```moonbit\nlet result: Result[Int, String] = Ok(42)\nlet new_result = result.map(fn(x) { x + 1 })\nassert_eq!(new_result, Ok(43))\n```\n\nA dual method to `map` is `map_err`, which applies a function to the error value if the result is `Err`, and remains unchanged if it is `Ok`.\n```moonbit\nlet result: Result[Int, String] = Err(\"error\")\nlet new_result = result.map_err(fn(x) { x + \"!\" })\nassert_eq!(new_result, Err(\"error!\"))\n```\n\nYou can turn a `Result[T, E]` into a `Option[T]` by using the method `to_option`, which returns `Some(value)` if the result is `Ok`, and `None` if it is `Err`.\n```moonbit\nlet result: Result[Int, String] = Ok(42)\nlet option = result.to_option()\nassert_eq!(option, Some(42))\nlet result1: Result[Int, String] = Err(\"error\")\nlet option1 = result1.to_option()\nassert_eq!(option1, None)\n```\n\n### Monadic operations\nMoonbit provides monadic operations for `Result`, such as `flatten` and `bind`, which allow chaining of computations that return `Result`.\n```moonbit\nlet result: Result[Result[Int, String], String] = Ok(Ok(42))\nlet flattened = result.flatten()\nassert_eq!(flattened, Ok(42))\n```\n\nThe `bind` method is similar to `map`, but the function passed to it should return a `Result` value. \n```moonbit\nlet result: Result[Int, String] = Ok(42)\nlet new_result = result.bind(fn(x) { Ok(x + 1) })\nassert_eq!(new_result, Ok(43))\n```\n",
  "package_data": "moonbitlang/core/result/package_data.json",
  "source_files": [ "result.mbt" ]
}