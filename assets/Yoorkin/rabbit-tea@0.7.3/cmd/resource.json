{
  "kind": "package",
  "relative_path": "cmd",
  "module_path": "Yoorkin/rabbit-tea",
  "readme_content": "# Cmd\n\nThe `Cmd[Msg]` type represent a task that has not yet been executed. \nIt's a side effect managed by the runtime. The only way to run the command \nis return it from the `update` function:\n\n```mbt\nfn update(msg : Msg, model : Model) -> (Cmd[Msg], Model) {\n  match msg {\n    Msg::Click(id) => {\n      // create a command to tell rabbit-tea scroll to the element with the given id\n      let cmd = @nav.scroll_to(id) \n      let updated_model = {...}\n      (cmd, updated_model)\n    }\n  }\n}\n```\n\nThe `scroll_to` function creates a `cmd` value that is returned with the \n`updated_model`. This means the scrolling action does not occur immediately. \nInstead, it will scroll to the element with the specified `id` after the \n`updated_model` has been rendered.\n\n# Custom Command\n\nYou can encapsulate a command to interoperate Rabbit-Tea with the external \nJavaScript world.\n\nThe `Cmd` type acts as a wrapper for a callback function that will be executed \nby the runtime at a later point:\n\n```mbt\ntype Cmd[M] (Events[M]) -> Unit\n```\n\nIt accepts the `Events[M]` type as a parameter, which is a collection of events \nthat can be triggered by your command. The most common usage is to trigger \nanother update with a message:\n\n```mbt\nfn delay[M](msg : M, ms : Int) -> Cmd[M] {\n  Cmd(fn(events){\n    set_timeout(fn(){ events.trigger_update(msg) }, ms)\n  })\n} \n\nextern \"js\" fn set_timeout(f : () -> Unit, ms : Int) = \"(f,ms) => setTimeout(f, ms)\"\n```\n\nThe `@http` package is also implemented in a similar manner.\n\nFor a complete example, refer to `src/example/custom_command`.\n\n# Design Considerations\n\nWhy do we wrap tasks in `Cmd` instead of running them immediately? \nHere are some reasons:\n\n1. **Tasks Need to Run After the New Model Is Rendered**\n\n    - As shown in the example above, the `scroll_to` function must execute after \n    the new model is rendered. If it runs immediately, the scroll action may not \n    work as expected.\n\n    - For instance, you might need to update the UI to a loading state before \n    fetching data. If the HTTP task is executed immediately, the app could lose \n    responsiveness.\n\n    You might ask: \"Why not make the `update` function asynchronous so tasks can \n    run asynchronously, allowing the UI to update between those tasks?\" Here's \n    another reason:\n\n2. **Encourages users follows the *Single Source of Truth* Principle**\n\n    The *single source of truth* principle ensures that the new model and view \n    are computed based on a single, consistent model.\n\n    If the `update` function were asynchronous, updates could overlap, leading \n    to situations where one update process occurs before another is completed. \n    This could result in inconsistent states or unexpected behavior.\n\n    ```\n               +---> update(msg1, old_model) ---> new_model1\n               |  \n    old_model--+\n               |\n               +---> update(msg2, old_model) ---> new_model2\n    ```\n\n    Now you have two models, `new_model1` and `new_model2`. Which model should \n    be used in the view?\n\n    In some other UI frameworks, this issue could occur. In rabbit-tea, it can \n    be avoided by using the `Cmd` pattern. If you doesn't use asynchronous \n    functions in update, e.g. `@cmd.attempt` and `@cmd.perform`, you will never \n    met this problem.\n\n\n\n\n\n",
  "package_data": "Yoorkin/rabbit-tea/cmd/package_data.json",
  "source_files": [ "command.mbt" ]
}